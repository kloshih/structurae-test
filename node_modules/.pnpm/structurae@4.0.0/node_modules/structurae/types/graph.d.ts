import type { AdjacencyStructureConstructor, TypedArrayConstructors } from "./utility-types.js";
export declare const Colors: {
    readonly WHITE: 0;
    readonly GRAY: 1;
    readonly BLACK: 2;
};
export declare type Colors = typeof Colors[keyof typeof Colors];
/**
 * Creates a Graph class extending a given adjacency structure.
 */
export declare function GraphMixin<T extends TypedArrayConstructors, U extends AdjacencyStructureConstructor<T>>(Base: U): {
    new (...args: any[]): {
        [n: number]: number;
        _colors?: Uint8Array | undefined;
        readonly colors: Uint8Array;
        hasColor(vertex: number, color: Colors): boolean;
        /**
         * Checks whether the graph is acyclic.
         */
        isAcyclic(): boolean;
        /**
         * Returns a list of vertices along the shortest path between two given vertices.
         *
         * @param start the starting vertex
         * @param end the ending vertex
         * @param isAcyclic whether the graph is acyclic
         * @param isNonNegative whether all edges are non-negative
         */
        path(start: number, end: number, isAcyclic?: boolean, isNonNegative?: boolean): Array<number>;
        /**
         * Resets all coloring of vertices done during traversals.
         */
        resetColors(): void;
        /**
         * For all.
         *
         * @param start
         * @param end
         * @param distances
         * @param predecessors
         */
        searchBellmanFord(start: number, end: number, distances: Array<number>, predecessors: Array<number>): boolean;
        /**
         * For non-negative edges.
         *
         * @param start
         * @param end
         * @param distances
         * @param predecessors
         */
        searchDijkstra(start: number, end: number, distances: Array<number>, predecessors: Array<number>): boolean;
        /**
         * For DAGs only.
         *
         * @param start
         * @param end
         * @param distances
         * @param predecessors
         */
        searchTopological(start: number, end: number, distances: Array<number>, predecessors: Array<number>): boolean;
        /**
         * For unweighted graphs.
         *
         * @param start the starting vertex
         * @param end the ending vertex
         * @param predecessors
         */
        searchUnweighted(start: number, end: number | undefined, predecessors: Array<number>): boolean;
        setColor(vertex: number, color: Colors): void;
        /**
         * Returns a list of vertexes sorted topologically.
         */
        topologicalSort(): Array<number>;
        /**
         * Does a Breadth-First or Depth-First traversal of the graph.
         *
         * @param isDFS whether to do DFS traversal, does BFS otherwise
         * @param start the vertex to start at
         * @param gray whether to return vertices upon entering
         * @param white whether to return edges upon first encountering
         * @param black whether to return vertices after processing
         * @return the vertex at each step
         */
        traverse(isDFS?: boolean, start?: number, gray?: boolean, white?: boolean, black?: boolean): Generator<number, void, unknown>;
        /**
         * Returns a minimal spanning tree of the graph.
         * Uses the Prim's algorithm for weighted graphs and BFS tree for unweighted graphs.
         *
         * @param start
         */
        tree(start?: number): any[];
        empty: unknown;
        vertices: number;
        edges: number;
        addEdge(x: number, y: number, weight?: number | undefined): any;
        getEdge(x: number, y: number): number;
        hasEdge(x: number, y: number): boolean;
        inEdges(x: number): Generator<number, void, unknown>;
        isFull(): boolean;
        outEdges(x: number): Generator<number, void, unknown>;
        removeEdge(x: number, y: number): any;
        length: number;
    };
    directed: boolean;
    weighted: boolean;
    create<T_1 extends AdjacencyStructureConstructor<T>>(this: T_1, vertices: number, edges?: number | undefined): InstanceType<T_1>;
    getLength(vertices: number, edges?: number | undefined): number;
    readonly [Symbol.species]: T;
} & U;
