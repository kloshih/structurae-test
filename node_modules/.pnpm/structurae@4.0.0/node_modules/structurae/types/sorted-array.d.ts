import type { IndexedCollection } from "./utility-types.js";
export declare type Comparator<T> = (a: T, b: T) => -1 | 0 | 1;
/**
 * Extends Array to handle sorted data.
 */
export declare class SortedArray<ItemType> extends Array<ItemType> {
    unique: boolean;
    /**
     * The default comparator.
     *
     * @param a the first value
     * @param b the second value
     * @throws RangeError if the comparison is unstable
     */
    static compare<T>(a: T, b: T): -1 | 0 | 1;
    /**
     * Creates a new SortedArray from a given array-like object.
     */
    static from<T>(iterable: Iterable<T> | ArrayLike<T>): SortedArray<T>;
    /**
     * Returns the difference of two sorted arrays,
     * i.e. elements present in the first array but not in the second array.
     * If `symmetric=true` finds the symmetric difference of two arrays, that is,
     * the elements that are absent in one or another array.
     *
     * @param a the first array
     * @param b the second array
     * @param [symmetric=false] whether to get symmetric difference.
     * @param [comparator] the comparator static used to sort the arrays
     * @param [container] an array-like object to hold the results
     * @return the difference of the arrays
     * @example
     *
     * SortedArray.getDifference([1, 2, 3, 4, 8], [2, 4, 6, 7, 9]);
     * //=> [ 1, 3, 8 ]
     *
     * // symmetric difference of sorted arrays:
     * SortedArray.getDifference(first, second, true);
     * //=> [ 1, 3, 6, 7, 8, 9 ]
  
     * // difference using a custom comparator:
     * const customComparator = (a, b) => (a > b ? -1 : a < b ? 1 : 0);
     * SortedArray.getDifference([8, 4, 3, 2, 1], [9, 7, 6, 4, 2], false, customComparator);
     * //=> [ 8, 3, 1 ]
     */
    static getDifference<T, U extends IndexedCollection<T>>(a: U, b: U, symmetric?: boolean, comparator?: Comparator<T>, container?: U): typeof container;
    /**
     * Returns the amount of differing elements in the first array.
     *
     * @param a the first array
     * @param b the second array
     * @param [symmetric=false] whether to use symmetric difference
     * @param [comparator] the comparator static used to sort the arrays
     * @return the amount of differing elements
     * @example
     *
     * SortedArray.getDifferenceScore([1, 2, 3, 4, 8], [2, 4, 6, 7, 9]);
     * //=> 3
     */
    static getDifferenceScore<T, U extends IndexedCollection<T>>(a: U, b: U, symmetric?: boolean, comparator?: typeof SortedArray.compare): number;
    /**
     * Uses binary search to find the index of an element inside a sorted array.
     *
     * @param arr the array to search
     * @param target the target value to search for
     * @param [comparator] a custom comparator
     * @param [rank=false] whether to return the element's rank if the element isn't found
     * @param [start] the start position of the search
     * @param [end] the end position of the search
     * @return the index of the searched element or it's rank
     * @example
     *
     * SortedArray.getIndex([1, 2, 3, 4, 8], 4);
     * //=> 3
     */
    static getIndex<T, U extends IndexedCollection<T>>(arr: U, target: T, comparator?: Comparator<T>, rank?: boolean, start?: number, end?: number): number;
    /**
     * Returns the intersection of two sorted arrays.
     *
     * @param a the first array
     * @param b the second array
     * @param [comparator] the comparator static used to sort the arrays
     * @param [container] an array-like object to hold the results
     * @return the intersection of the arrays
     * @example
     *
     * SortedArray.getIntersection([1, 2, 3, 4, 8], [2, 4, 6, 7, 9]);
     * //=> [ 2, 4 ]
     *
     * // intersection using a custom comparator:
     * const customComparator = (a, b) => (a > b ? -1 : a < b ? 1 : 0);
     * SortedArray.getIntersection([8, 4, 3, 2, 1], [9, 7, 6, 4, 2], customComparator);
     * //=> [ 4, 2 ]
     */
    static getIntersection<T, U extends IndexedCollection<T>>(a: U, b: U, comparator?: Comparator<T>, container?: U): U;
    /**
     * Returns the amount of common elements in two sorted arrays.
     *
     * @param a the first array
     * @param b the second array
     * @param [comparator] the comparator static used to sort the arrays
     * @return the amount of different elements
     * @example
     *
     * SortedArray.getIntersection([1, 2, 3, 4, 8], [2, 4, 6, 7, 9]);
     * //=> 2
     */
    static getIntersectionScore<T, U extends IndexedCollection<T>>(a: U, b: U, comparator?: Comparator<T>): number;
    /**
     * Returns a range of elements of a sorted array from the start through the end inclusively.
     *
     * @param arr the array
     * @param [start] the starting item
     * @param [end] the ending item
     * @param [comparator] a custom comparator
     * @param [subarray] return a subarray instead of copying resulting value with slice
     * @return the range of items
     * @example
     *
     * SortedArray.getRange([1, 2, 3, 4, 8], 2, 4);
     * //=> [ 2, 3, 4 ]
     *
     * const customComparator = (a, b) => (a > b ? -1 : a < b ? 1 : 0);
     * SortedArray.getRange([8, 4, 3, 2, 1], 8, 3, customComparator);
     * //=> [ 8, 4, 3 ]
     */
    static getRange<T, U extends IndexedCollection<T>>(arr: U, start?: T, end?: T, comparator?: Comparator<T>, subarray?: boolean): U;
    /**
     * Returns the union of two sorted arrays as a sorted array.
     *
     * @param a the first array
     * @param b the second array
     * @param [unique=false] whether to avoid duplicating items when merging unique arrays
     * @param [comparator] the comparator static used to sort the arrays
     * @param [container] an array-like object to hold the results
     * @return the union of the arrays
     * @example
     *
     * SortedArray.getUnion([1, 2, 3, 4, 8], [2, 4, 6, 7, 9]);
     * //=> [ 1, 2, 2, 3, 4, 4, 6, 7, 8, 9 ]
     *
     * // union of sorted arrays without duplicates:
     * SortedArray.getUnion([1, 2, 3, 4, 8], [2, 4, 6, 7, 9], true);
     * //=> [ 1, 2, 3, 4, 6, 7, 8, 9 ]
     *
     * //union using a custom comparator:
     * SortedArray.getUnion([8, 4, 3, 2, 1], [9, 7, 6, 4, 2], true, customComparator);
     * //=> [ 9, 8, 7, 6, 4, 3, 2, 1 ]
     */
    static getUnion<T, U extends IndexedCollection<T>>(a: IndexedCollection<T>, b: IndexedCollection<T>, unique?: boolean, comparator?: Comparator<T>, container?: U): U;
    /**
     * Returns an array of unique elements from a sorted array.
     *
     * @param arr the sorted array
     * @param [comparator] a custom comparator
     * @param [container] an array-like object to hold the results
     * @return the sorted array without duplicates
     * @example
     *
     * SortedArray.getUnique([1, 1, 2, 2, 3, 4]);
     * //=> [ 1, 2, 3, 4 ]
     */
    static getUnique<T, U extends IndexedCollection<T>>(arr: IndexedCollection<T>, comparator?: Comparator<T>, container?: U): typeof container;
    /**
     * Checks whether an array is sorted according to a provided comparator.
     *
     * @param arr the array to check
     * @param [comparator] a custom comparator
     * @return whether the array is sorted
     *
     * @example
     *
     * SortedArray.isSorted([1, 2, 3, 4, 8]);
     * //=> true
     */
    static isSorted<T, U extends IndexedCollection<T>>(arr: U, comparator?: Comparator<T>): boolean;
    /**
     * Checks whether an array has any duplicating elements.
     *
     * @param arr the array to check
     * @param [comparator] a custom comparator
     * @return whether the array has duplicating elements
     * @example
     *
     * SortedArray.isUnique([1, 2, 2, 3, 4]);
     * //=> false
     */
    static isUnique<T, U extends IndexedCollection<T>>(arr: U, comparator?: Comparator<T>): boolean;
    /**
     * Creates a new SortedArray instance with a variable number of arguments,
     * regardless of number or type of the arguments
     *
     * @param elements the elements of which to create the array
     * @return the new SortedArray
     */
    static of<U>(...elements: Array<U>): SortedArray<U>;
    /**
     * Returns a merger of the array with one or more provided sorted arrays.
     *
     * @param arrays sorted array(s) to merge
     * @return a new SortedArray
     */
    concat(...arrays: Array<Array<ItemType>>): SortedArray<ItemType>;
    /**
     * Uses binary search to quickly check if the element is the array.
     * @param element the element to check
     * @return whether the element is in the array
     */
    includes(element: ItemType): boolean;
    /**
     * Looks for the index of a given element in the array or -1
     *
     * @param element the element to look for
     * @return the element's index in the array or -1
     */
    indexOf(element: ItemType): number;
    /**
     * Checks if the array is sorted.
     *
     * @return whether the array is sorted
     * @example
     *
     * //=> SortedArray [ 2, 3, 4, 5, 9 ];
     * SortedArray.isSorted();
     * //=> true
     * SortedArray.reverse();
     * SortedArray.isSorted();
     * //=> false;
     */
    isSorted(): boolean;
    /**
     * Checks if the array has duplicating elements.
     *
     * @return whether the array has duplicating elements
     * @example
     *
     * //=> SortedArray [ 2, 3, 3, 4, 5, 9 ];
     * SortedArray.isUnique();
     * //=> false;
     */
    isUnique(): boolean;
    /**
     * Adds provided elements to the array preserving the sorted order of the array.
     *
     * @param elements the elements to add to the array
     * @return the new length of the array
     */
    push(...elements: Array<ItemType>): number;
    /**
     * Returns a range of elements of the array that are greater or equal to the provided
     * starting element and less or equal to the provided ending element.
     *
     * @param start the starting element
     * @param end the ending element
     * @return the resulting range of elements
     * @example
     *
     * //=> SortedArray [ 2, 3, 4, 5, 9 ];
     * SortedArray.range(3, 5);
     * // => [ 3, 4, 5 ]
     * SortedArray.range(undefined, 4);
     * // => [ 2, 3, 4 ]
     * SortedArray.range(4);
     * // => [ 4, 5, 8 ]
     */
    range(start?: ItemType, end?: ItemType): SortedArray<ItemType>;
    /**
     * Returns the rank of an element in the array.
     *
     * @param element the element to look for
     * @return the rank in the array
     * @example
     *
     * //=> SortedArray [ 2, 3, 4, 5, 9 ];
     * SortedArray.rank(1);
     * // => 0
     * SortedArray.rank(6);
     * // => 4
     */
    rank(element: ItemType): number;
    /**
     * Implements in-place replacement of the array elements.
     *
     * @param arr an array of new elements to use
     *
     * @example
     *
     * //=> SortedArray [ 2, 3, 4, 5, 9 ];
     * sortedArray.set([1, 2, 3]);
     * //=> SortedArray [ 1, 2, 3 ]
     */
    set(arr: Array<ItemType>): this;
    /**
     * Sorts the array with a provided compare function.
     *
     * @param compareFunction the function to use for comparison
     */
    sort(compareFunction?: Comparator<ItemType>): this;
    /**
     * Changes the array by removing existing elements and adding new ones.
     *
     * @param start the index at which to start changing the array
     * @param deleteCount the amount of old elements to delete
     * @param elements the elements to add to the array
     * @return an array of deleted elements
     */
    splice(start: number, deleteCount: number, ...elements: Array<ItemType>): SortedArray<ItemType>;
    /**
     * Removes duplicating elements from the array.
     *
     * @example
     *
     * //=> SortedArray [ 2, 2, 3, 4, 5, 5, 9 ];
     * sortedArray.uniquify();
     * // => SortedArray [ 2, 3, 4, 5, 9 ]
     */
    uniquify(): this;
    /**
     * Adds provided elements to the array preserving the sorted order of the array.
     *
     * @param elements the elements to add to the array
     * @return the new length of the array
     */
    unshift(...elements: Array<ItemType>): number;
}
