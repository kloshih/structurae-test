import type { UnknownViewConstructor, ViewConstructor, ViewFieldLayout, ViewInstance, ViewLayout, ViewSchema } from "./view-types.js";
import type { Constructor } from "./utility-types.js";
export declare class View {
    maxView: DataView;
    Views: Map<string, UnknownViewConstructor>;
    TaggedViews: Map<number, UnknownViewConstructor>;
    static AbstractViews: Set<string>;
    constructor(maxView?: DataView);
    create<T>(schema: ViewSchema<T>, constructor?: T extends object ? Constructor<T> : never): ViewConstructor<T>;
    view<T>(view: DataView): ViewInstance<T> | undefined;
    decode<T>(view: DataView): T | undefined;
    encode<T extends {
        tag: number;
    }>(value: T, view?: DataView, offset?: number): ViewInstance<T> | undefined;
    getTag(view: DataView): number;
    getSchemaTag(schema: ViewSchema<object>): number | undefined;
    getArray<T>(schema: ViewSchema<T>): [view: ViewConstructor<T>, length: number];
    getArrayView<T>(schema: ViewSchema<T>, SchemaView?: ViewConstructor<T>, length?: number): ViewConstructor<Array<T>>;
    static getDefaultData<T extends unknown>(layout: ViewLayout<T>, viewLength: number, fields: Array<keyof T>): Uint8Array;
    static getDefaultConstructor<T>(fields: Array<keyof T>, layout: ViewLayout<T>): Constructor<T>;
    getExistingView<T>(schema: ViewSchema<T>): ViewConstructor<T>;
    getFieldLayout<T>(field: ViewSchema<T>, start: number, required: boolean, name: string): ViewFieldLayout<T>;
    static getSchemaId(schema: ViewSchema<any>): string;
    static getSchemaOrdering(schema: ViewSchema<unknown>): Array<ViewSchema<object>>;
}
