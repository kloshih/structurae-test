export class VectorView extends DataView {
    get size() {
        return this.constructor.getSize(this);
    }
    static decode(view, start = 0) {
        const View = this.View;
        const size = this.getSize(view, start);
        const array = new Array(size);
        for (let i = 0; i < size; i++) {
            const offset = this.getOffset(i, view, start);
            array[i] = offset
                ? View.decode(view, start + offset[0], offset[1])
                : undefined;
        }
        return array;
    }
    static encode(value, view, start = 0, length) {
        const { View } = this;
        const items = value.length;
        const lastOffset = (items + 1) << 2;
        let end = lastOffset + 4;
        let availableSpace = (length ?? view.byteLength) - end;
        if (availableSpace < 1)
            return 0;
        view.setUint32(start, items, true);
        for (let i = 0; i < items; i++) {
            const item = value[i];
            const itemOffset = (i + 1) << 2;
            view.setUint32(start + itemOffset, end, true);
            let itemLength = 0;
            if (item != null) {
                const caret = start + end;
                if (View.viewLength || View.itemLength) {
                    itemLength = View.getLength(value.length);
                    // stop encoding if no more space is available
                    if (itemLength > availableSpace)
                        continue;
                    View.encode(item, view, caret, itemLength);
                }
                else {
                    itemLength = View.encode(item, view, caret, length ? availableSpace : undefined);
                }
                end += itemLength;
                availableSpace -= itemLength;
            }
        }
        view.setUint32(start + lastOffset, end, true);
        return end;
    }
    static from(value) {
        const { maxView } = this;
        const end = this.encode(value, maxView);
        return new this(maxView.buffer.slice(0, end));
    }
    static getLength(value) {
        const { View } = this;
        const items = value.length;
        let length = (items + 2) << 2;
        for (let i = 0; i < value.length; i++) {
            if (value[i] !== undefined) {
                length += View.getLength(value[i]);
            }
        }
        return length;
    }
    static getOffset(index, view, start = 0) {
        const offset = start + ((index + 1) << 2);
        const begin = view.getUint32(offset, true);
        const end = view.getUint32(offset + 4, true);
        if (begin === end)
            return undefined;
        return [begin, end - begin];
    }
    static getSize(view, start = 0) {
        return view.getUint32(start, true);
    }
    static indexOf(value, view, startIndex = 0, startOffset = 0) {
        const size = this.getSize(view, startOffset);
        const valueView = this.View.from(value);
        outer: for (let i = startIndex; i < size; i++) {
            const offset = this.getOffset(i, view, startOffset);
            if (!offset || offset[1] !== valueView.byteLength)
                continue;
            for (let j = 0; j < valueView.byteLength; j++) {
                if (valueView.getUint8(j) !== view.getUint8(offset[0] + j)) {
                    continue outer;
                }
            }
            return i;
        }
        return -1;
    }
    *[Symbol.iterator]() {
        const { size } = this;
        for (let i = 0; i < size; i++) {
            yield this.getView(i);
        }
    }
    at(index) {
        if (index < 0)
            return this.get(this.size + index);
        return this.get(index);
    }
    get(index) {
        const View = this.constructor
            .View;
        const offset = this.getOffset(index);
        if (!offset)
            return undefined;
        return View.decode(this, offset[0], offset[1]);
    }
    getLength(index) {
        const offset = this.getOffset(index);
        return offset ? offset[1] : 0;
    }
    getOffset(index) {
        const length = this.getUint32(0, true);
        if (index >= length)
            return undefined;
        return this.constructor.getOffset(index, this, 0);
    }
    getView(index) {
        const View = this.constructor
            .View;
        const offset = this.getOffset(index);
        if (!offset)
            return undefined;
        return new View(this.buffer, this.byteOffset + offset[0], offset[1]);
    }
    indexOf(value, start = 0) {
        return this.constructor.indexOf(value, this, start, 0);
    }
    set(index, value) {
        const View = this.constructor
            .View;
        const offset = this.getOffset(index);
        if (!offset)
            return undefined;
        View.encode(value, this, this.byteOffset + offset[0], offset[1]);
    }
    setView(index, value) {
        const offset = this.getOffset(index);
        if (!offset)
            return undefined;
        new Uint8Array(this.buffer, this.byteOffset + offset[0], offset[1]).set(new Uint8Array(value.buffer, value.byteOffset, value.byteLength));
    }
    toJSON() {
        return this.constructor.decode(this, 0);
    }
    static initialize(schema, Factory, SchemaView) {
        var _a;
        const ItemView = SchemaView ?? Factory.getExistingView(schema);
        return _a = class extends this {
            },
            Object.defineProperty(_a, "View", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: ItemView
            }),
            Object.defineProperty(_a, "maxView", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: Factory.maxView
            }),
            _a;
    }
}
Object.defineProperty(VectorView, "viewLength", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 0
});
//# sourceMappingURL=vector-view.js.map