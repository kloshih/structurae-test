/**
 * Creates an Adjacency Matrix class extending a given TypedArray class.
 *
 * @param Base a TypedArray class to extend
 */
export function AdjacencyMatrixWeightedDirectedMixin(Base) {
    /**
     * Implements Adjacency Matrix for weighted directed graphs.
     */
    class AdjacencyMatrixWeightedDirected extends Base {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "empty", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
            Object.defineProperty(this, "_vertices", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 0
            });
        }
        static get [Symbol.species]() {
            return Base;
        }
        get vertices() {
            return (this._vertices ||
                (this._vertices = this
                    .constructor.getVertices(this.length)), this._vertices);
        }
        get edges() {
            return this.vertices ** 2;
        }
        static create(vertices) {
            const length = this.getLength(vertices);
            return new this(length);
        }
        static getLength(vertices) {
            return vertices * vertices;
        }
        static getVertices(length) {
            return Math.sqrt(length);
        }
        addEdge(x, y, weight) {
            this[this.getIndex(x, y)] = weight;
            return this;
        }
        getEdge(x, y) {
            return this[this.getIndex(x, y)];
        }
        getIndex(x, y) {
            return x * this.vertices + y;
        }
        hasEdge(x, y) {
            const edge = this.getEdge(x, y);
            return edge !== undefined && edge !== this.empty;
        }
        *inEdges(vertex) {
            const { vertices } = this;
            for (let i = 0; i < vertices; i++) {
                if (this.hasEdge(i, vertex))
                    yield i;
            }
        }
        isFull() {
            return false;
        }
        *outEdges(vertex) {
            const { vertices } = this;
            const offset = vertex * vertices;
            for (let i = 0; i < vertices; i++) {
                const edge = this[offset + i];
                if (edge !== undefined && edge !== this.empty)
                    yield i;
            }
        }
        removeEdge(x, y) {
            this[this.getIndex(x, y)] = this.empty;
            return this;
        }
    }
    Object.defineProperty(AdjacencyMatrixWeightedDirected, "directed", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
    });
    Object.defineProperty(AdjacencyMatrixWeightedDirected, "weighted", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
    });
    return AdjacencyMatrixWeightedDirected;
}
//# sourceMappingURL=adjacency-matrix-weighted-directed.js.map