{"version":3,"file":"bit-field.js","sourceRoot":"","sources":["../src/bit-field.ts"],"names":[],"mappings":"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","sourcesContent":["import { getBitSize } from \"./utilities.js\";\nimport type {\n  BitFieldConstructor,\n  BitFieldStructure,\n} from \"./bit-field-types.js\";\n\nconst SIGN_BIT = 2147483647;\nconst MAX_BITWISE_SIZE = 31;\n\nclass BitField<\n  K extends PropertyKey,\n> implements BitFieldStructure<K, number> {\n  static schema: Record<PropertyKey, number>;\n  static fields: Array<PropertyKey>;\n  static masks: Record<PropertyKey, number>;\n  static offsets: Record<PropertyKey, number>;\n  static mask = 2 << 30;\n  static size = 31;\n  value = 0;\n\n  constructor(\n    data: number | BitField<K> | Array<number> | Record<K, number> = 0,\n  ) {\n    this.value = typeof data === \"number\"\n      ? data\n      : data instanceof BitField\n      ? data.valueOf()\n      : (this.constructor as typeof BitField).encode(data);\n  }\n\n  static decode<K extends PropertyKey>(\n    data: number,\n  ): Record<K, number> {\n    const schema = this.schema as Record<K, number>;\n    const fields = this.fields as Array<K>;\n    const masks = this.masks as Record<K, number>;\n    const result = {} as Record<K, number>;\n    let value = data;\n    for (let i = 0; i < fields.length; i++) {\n      const field = fields[i];\n      const size = schema[field];\n      result[field] = value & masks[field];\n      value >>= size;\n    }\n    return result;\n  }\n\n  static encode<K extends PropertyKey>(\n    data: Array<number> | Record<K, number>,\n  ): number {\n    const schema = this.schema as Record<K, number>;\n    const fields = this.fields as Array<K>;\n    const array = Array.isArray(data)\n      ? data\n      : fields.map((name) => data[name] || 0);\n    let result = 0;\n    for (let i = fields.length - 1; i >= 0; i--) {\n      const field = fields[i];\n      const current = array[i];\n      result <<= schema[field];\n      result |= current;\n    }\n    return result;\n  }\n\n  static getMatcher<K extends PropertyKey>(\n    matcher: Partial<Record<K, number>>,\n  ): [number, number] {\n    const masks = this.masks as Record<K, number>;\n    const offsets = this.offsets as Record<K, number>;\n    const fields = Object.keys(matcher) as Array<K>;\n    let mask = 0;\n    let value = 0;\n    for (let i = 0; i < fields.length; i++) {\n      const fieldName = fields[i];\n      const fieldMask = masks[fieldName] << offsets[fieldName];\n      const fieldValue = matcher[fieldName]!;\n      value = (value & ~fieldMask) | (fieldValue << offsets[fieldName]);\n      mask |= fieldMask;\n    }\n    return [value, this.mask ^ mask];\n  }\n\n  static getMinSize(number: number): number {\n    return getBitSize(number);\n  }\n\n  static isValid<T extends Record<K, number>, K extends keyof T>(\n    data: T,\n  ): boolean {\n    const masks = this.masks as T;\n    const fields = Object.keys(data) as Array<K>;\n    for (let i = 0; i < fields.length; i++) {\n      const field = fields[i];\n      const value = data[field];\n      if ((value & SIGN_BIT) !== value || value > masks[field]) return false;\n    }\n    return true;\n  }\n\n  static match(value: number, matcher: [number, number]): boolean {\n    return (value & matcher[1]) === matcher[0];\n  }\n\n  *[Symbol.iterator](): Generator<number> {\n    const fields = (this.constructor as BitFieldConstructor<K>).fields;\n    for (let i = 0; i < fields.length; i++) {\n      yield this.get(fields[i]);\n    }\n  }\n\n  get(field: K): number {\n    const { offsets, masks } = this.constructor as BitFieldConstructor<K>;\n    return (this.value >> offsets[field]) & masks[field];\n  }\n\n  has(...fields: Array<K>): boolean {\n    const { offsets } = this.constructor as BitFieldConstructor<K>;\n    let mask = 0;\n    for (let i = 0; i < fields.length; i++) {\n      mask |= 1 << offsets[fields[i]];\n    }\n    mask |= this.value;\n    return this.value === mask;\n  }\n\n  match(matcher: Partial<Record<K, number>> | [number, number]): boolean {\n    return (this.constructor as BitFieldConstructor<K>).match(\n      this.value,\n      Array.isArray(matcher)\n        ? matcher\n        : (this.constructor as BitFieldConstructor<K>).getMatcher(matcher),\n    );\n  }\n\n  set(field: K, value = 1): this {\n    const { offsets, masks } = this.constructor as BitFieldConstructor<K>;\n    this.value = (this.value & ~(masks[field] << offsets[field])) |\n      (value << offsets[field]);\n    return this;\n  }\n\n  toJSON() {\n    return this.value;\n  }\n\n  toObject(): Record<K, number> {\n    return (this.constructor as BitFieldConstructor<K>).decode(this.value);\n  }\n\n  toString(): string {\n    return this.value.toString();\n  }\n\n  valueOf(): number {\n    return this.value;\n  }\n}\n\n/**\n * Creates a BitField class from with a given schema. BitField uses numbers as bitfields\n * to store and operate on data using bitwise operations. The size of the field is limited to 31 bits,\n * for a larger bitfields consider using BigBitField class that uses bigints instead.\n *\n * @param schema the schema\n * @returns the BitFieldClass\n *\n * @example\n * const Field = BitFieldMixin({ width: 8, height: 8 });\n * const field = new Field({ width: 100, height: 200 });\n * field.get('width');\n * //=> 100;\n * field.get('height');\n * //=> 200\n * field.set('width', 18);\n * field.get('width');\n * //=> 18\n * field.toObject();\n * //=> { width: 18, height: 200 }\n */\nexport function BitFieldMixin<\n  T extends Record<K, number>,\n  K extends keyof T,\n>(schema: T): BitFieldConstructor<K> {\n  const fields = Object.keys(schema) as Array<K>;\n  const masks = {} as Record<K, number>;\n  const offsets = {} as Record<K, number>;\n  let lastOffset = 0;\n  for (let i = 0; i < fields.length; i++) {\n    const field = fields[i];\n    const size = schema[field];\n    masks[field] = (2 << (size - 1)) - 1;\n    offsets[field] = lastOffset;\n    lastOffset += size;\n  }\n  if (lastOffset > MAX_BITWISE_SIZE) {\n    throw TypeError(\"The total size of the bitfield exceeds 31 bits.\");\n  }\n\n  return class extends BitField<K> {\n    static schema = schema;\n    static fields = fields;\n    static masks = masks;\n    static offsets = offsets;\n    size = lastOffset;\n    mask = 2 << (lastOffset - 1);\n  };\n}\n\nconst _BitField = BitFieldMixin({\n  0: 1,\n  1: 1,\n  2: 1,\n  3: 1,\n  4: 1,\n  5: 1,\n  6: 1,\n  7: 1,\n  8: 1,\n  9: 1,\n  10: 1,\n  11: 1,\n  12: 1,\n  13: 1,\n  14: 1,\n  15: 1,\n  16: 1,\n  17: 1,\n  18: 1,\n  19: 1,\n  20: 1,\n  21: 1,\n  22: 1,\n  23: 1,\n  24: 1,\n  25: 1,\n  26: 1,\n  27: 1,\n  28: 1,\n  29: 1,\n  30: 1,\n});\n\nexport { _BitField as BitField };\n"]}