{"version":3,"file":"bit-field-types.js","sourceRoot":"","sources":["../src/bit-field-types.ts"],"names":[],"mappings":"","sourcesContent":["export interface BitFieldStructure<\n  K extends PropertyKey,\n  N extends number | bigint = number,\n> {\n  value: N;\n  /**\n   * Iterates over numbers stored in the instance.\n   */\n  [Symbol.iterator](): Generator<number>;\n  /**\n   * Returns the value of a given field.\n   *\n   * @param field the name of the field\n   * @return value of the field\n   */\n  get(field: K): number;\n  /**\n   * Checks whether the instance has all the specified fields set to 1. Useful for bit flags.\n   *\n   * @param fields names of the fields to check\n   * @return whether all the specified fields are set in the instance\n   */\n  has(...fields: Array<K>): boolean;\n  /**\n   * Checks if the instance contains all the key-value pairs listed in matcher.\n   * Use `BigBitField.getMatcher` to get an array of precomputed values\n   * that you can use to efficiently compare multiple instances\n   * to the same key-value pairs as shown in the examples below.\n   *\n   * @param matcher an object with key-value pairs, or an array of precomputed matcher values\n   * @return whether the instance matches with the provided fields\n   */\n  match(matcher: Partial<Record<K, number>> | [N, N]): boolean;\n  /**\n   * Stores a given value in a field.\n   *\n   * @param field name of the field\n   * @param value value of the field\n   * @return the instance\n   */\n  set(field: K, value?: number): this;\n  /**\n   * Returns the bigint value of an instance.\n   */\n  toJSON(): N;\n  /**\n   * Returns the object representation of the instance,\n   * with field names as properties with corresponding values.\n   */\n  toObject(): Record<K, number>;\n  /**\n   * Returns a string representing the value of the instance.\n   */\n  toString(): string;\n  /**\n   * Returns the bigint value of an instance.\n   */\n  valueOf(): N;\n}\n\nexport interface BitFieldConstructor<\n  K extends PropertyKey,\n  N extends number | bigint = number,\n> {\n  schema: Record<K, N>;\n  fields: Array<K>;\n  masks: Record<K, N>;\n  offsets: Record<K, N>;\n  mask: N;\n  size: N;\n  /**\n   * @param data a single numerical value of the bitfield,\n   * a bitfield, or a map of field names with their respective values\n   */\n  new (\n    data?: N | BitFieldStructure<K, N> | Array<number> | Record<K, number>,\n  ): BitFieldStructure<K, N>;\n  /**\n   * Decodes a numeric value into its object representation according to the schema.\n   *\n   * @param data a numeric value\n   * @return object representation\n   */\n  decode(data: N): Record<K, number>;\n  /**\n   * Encodes a given list of numbers or map of fields and their respective values\n   * into a single numeric value according to the schema.\n   *\n   * @param data a list of numbers or an object to encode\n   * @return encoded numeric value\n   */\n  encode(data: Array<number> | Record<K, number>): N;\n  /**\n   * Creates a tuple of values to be used as a matcher\n   * to efficiently match against multiple instances.\n   *\n   * @param matcher an object containing field names and their values\n   * @return a tuple of precomputed values\n   */\n  getMatcher(matcher: Partial<Record<K, number>>): [N, N];\n  /**\n   * Returns the minimum amount of bits necessary to hold a given number.\n   *\n   * @param number\n   * @return the amount of bits\n   */\n  getMinSize(value: number): number;\n  /**\n   * Checks if a given set of values are valid according to the schema.\n   *\n   * @param data a map of field names and their values to check\n   * @return whether all pairs are valid\n   */\n  isValid(data: Partial<Record<K, number>>): boolean;\n  /**\n   * The static version of `BitField#match`, matches a given value against a precomputed matcher.\n   *\n   * @param value a value to check\n   * @param matcher a precomputed set of values\n   */\n  match(value: N, matcher: [N, N]): boolean;\n}\n"]}