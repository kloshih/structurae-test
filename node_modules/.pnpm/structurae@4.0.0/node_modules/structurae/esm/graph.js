import { BinaryHeap } from "./binary-heap.js";
export const Colors = {
    WHITE: 0,
    GRAY: 1,
    BLACK: 2,
};
class VertexHeap extends BinaryHeap {
    static compare(a, b) {
        return a.w < b.w;
    }
}
/**
 * Creates a Graph class extending a given adjacency structure.
 */
export function GraphMixin(Base) {
    /**
     * Extends an adjacency list/matrix structure and provides methods for traversal (BFS, DFS),
     * pathfinding (Dijkstra, Bellman-Ford), spanning tree construction (BFS, Prim), etc.
     */
    class Graph extends Base {
        constructor() {
            super(...arguments);
            Object.defineProperty(this, "_colors", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: void 0
            });
        }
        get colors() {
            return (this._colors ||
                ((this._colors = new Uint8Array(this.vertices)), this._colors));
        }
        hasColor(vertex, color) {
            return this.colors[vertex] === color;
        }
        /**
         * Checks whether the graph is acyclic.
         */
        isAcyclic() {
            for (const vertex of this.traverse(true, 0, false, true)) {
                if (!this.hasColor(vertex, Colors.WHITE))
                    return false;
            }
            return true;
        }
        /**
         * Returns a list of vertices along the shortest path between two given vertices.
         *
         * @param start the starting vertex
         * @param end the ending vertex
         * @param isAcyclic whether the graph is acyclic
         * @param isNonNegative whether all edges are non-negative
         */
        path(start, end, isAcyclic = false, isNonNegative = false) {
            const { weighted } = this
                .constructor;
            const { vertices } = this;
            const predecessors = new Array(vertices).fill(-1);
            const distances = new Array(vertices).fill(Infinity);
            const isFound = !weighted
                ? this.searchUnweighted(start, end, predecessors)
                : isAcyclic
                    ? this.searchTopological(start, end, distances, predecessors)
                    : isNonNegative
                        ? this.searchDijkstra(start, end, distances, predecessors)
                        : this.searchBellmanFord(start, end, distances, predecessors);
            if (!isFound)
                return [];
            const path = [];
            let last = end;
            while (~last) {
                path.unshift(last);
                last = predecessors[last];
            }
            return path;
        }
        /**
         * Resets all coloring of vertices done during traversals.
         */
        resetColors() {
            this.colors.fill(0);
        }
        /**
         * For all.
         *
         * @param start
         * @param end
         * @param distances
         * @param predecessors
         */
        searchBellmanFord(start, end, distances, predecessors) {
            const { vertices } = this;
            distances[start] = 0;
            let isFound = false;
            for (let i = 0; i < vertices; i++) {
                for (const edge of this.outEdges(i)) {
                    const weight = this.getEdge(i, edge);
                    const distance = distances[i] + weight;
                    if (distances[edge] > distance) {
                        distances[edge] = distance;
                        predecessors[edge] = i;
                        if (edge === end) {
                            isFound = true;
                        }
                    }
                }
            }
            return isFound;
        }
        /**
         * For non-negative edges.
         *
         * @param start
         * @param end
         * @param distances
         * @param predecessors
         */
        searchDijkstra(start, end, distances, predecessors) {
            this.resetColors();
            const heap = new VertexHeap();
            distances[start] = 0;
            heap.push({ e: start, w: this[start] });
            let isFound = false;
            while (heap.length) {
                const vertex = heap.shift();
                if (this.hasColor(vertex.e, Colors.GRAY))
                    continue;
                this.setColor(vertex.e, Colors.GRAY);
                for (const edge of this.outEdges(vertex.e)) {
                    const weight = this.getEdge(vertex.e, edge);
                    const distance = distances[vertex.e] + weight;
                    if (distance < distances[edge]) {
                        distances[edge] = distance;
                        predecessors[edge] = vertex.e;
                        heap.push({ e: edge, w: distance });
                    }
                    if (edge === end) {
                        isFound = true;
                    }
                }
            }
            return isFound;
        }
        /**
         * For DAGs only.
         *
         * @param start
         * @param end
         * @param distances
         * @param predecessors
         */
        searchTopological(start, end, distances, predecessors) {
            distances[start] = 0;
            let lastPredecessor = start;
            let isFound = false;
            for (const vertex of this.traverse(true, start, true, true)) {
                if (!this.hasColor(vertex, Colors.GRAY)) {
                    const weight = this.getEdge(lastPredecessor, vertex);
                    if (distances[vertex] > distances[lastPredecessor] + weight) {
                        distances[vertex] = distances[lastPredecessor] + weight;
                        predecessors[vertex] = lastPredecessor;
                    }
                }
                else if (!this.hasColor(vertex, Colors.BLACK)) {
                    lastPredecessor = vertex;
                }
                if (vertex === end) {
                    isFound = true;
                }
            }
            return isFound;
        }
        /**
         * For unweighted graphs.
         *
         * @param start the starting vertex
         * @param end the ending vertex
         * @param predecessors
         */
        searchUnweighted(start, end, predecessors) {
            let lastPredecessor = start;
            let isFound = false;
            for (const vertex of this.traverse(false, start, true, true)) {
                if (this.hasColor(vertex, Colors.BLACK))
                    continue;
                if (this.hasColor(vertex, Colors.WHITE)) {
                    predecessors[vertex] = lastPredecessor;
                }
                else {
                    lastPredecessor = vertex;
                }
                if (vertex === end) {
                    isFound = true;
                    break;
                }
            }
            return isFound;
        }
        setColor(vertex, color) {
            this.colors[vertex] = color;
        }
        /**
         * Returns a list of vertexes sorted topologically.
         */
        topologicalSort() {
            const result = [];
            for (const vertex of this.traverse(true, 0, false, false, true)) {
                result.unshift(vertex);
            }
            return result;
        }
        /**
         * Does a Breadth-First or Depth-First traversal of the graph.
         *
         * @param isDFS whether to do DFS traversal, does BFS otherwise
         * @param start the vertex to start at
         * @param gray whether to return vertices upon entering
         * @param white whether to return edges upon first encountering
         * @param black whether to return vertices after processing
         * @return the vertex at each step
         */
        *traverse(isDFS = false, start = 0, gray = true, white = false, black = false) {
            this.resetColors();
            const processing = [start];
            const [push, pull] = isDFS
                ? ["push", "pop"]
                : ["push", "shift"];
            while (processing.length) {
                const vertex = processing[pull]();
                this.setColor(vertex, Colors.GRAY);
                if (gray)
                    yield vertex;
                for (const edge of this.outEdges(vertex)) {
                    if (this.hasColor(edge, Colors.WHITE)) {
                        processing[push](edge);
                    }
                    if (white)
                        yield edge;
                }
                this.setColor(vertex, Colors.BLACK);
                if (black)
                    yield vertex;
            }
        }
        /**
         * Returns a minimal spanning tree of the graph.
         * Uses the Prim's algorithm for weighted graphs and BFS tree for unweighted graphs.
         *
         * @param start
         */
        tree(start = 0) {
            const { weighted } = this
                .constructor;
            const { vertices } = this;
            const predecessors = new Array(vertices).fill(-1);
            if (!weighted) {
                this.searchUnweighted(start, undefined, predecessors);
                return predecessors;
            }
            this.resetColors();
            const distances = new Array(vertices).fill(Infinity);
            const heap = new VertexHeap();
            distances[start] = 0;
            heap.push({ e: start, w: this[0] });
            while (heap.length) {
                const vertex = heap.shift();
                if (this.hasColor(vertex.e, Colors.GRAY))
                    continue;
                this.setColor(vertex.e, Colors.GRAY);
                for (const edge of this.outEdges(vertex.e)) {
                    const weight = this.getEdge(vertex.e, edge);
                    if (this.hasColor(edge, Colors.GRAY) || weight > distances[edge]) {
                        continue;
                    }
                    distances[edge] = weight;
                    predecessors[edge] = vertex.e;
                    heap.push({ e: edge, w: weight });
                }
            }
            return predecessors;
        }
    }
    return Graph;
}
//# sourceMappingURL=graph.js.map