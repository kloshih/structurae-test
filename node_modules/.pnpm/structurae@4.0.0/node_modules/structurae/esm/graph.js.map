{"version":3,"file":"graph.js","sourceRoot":"","sources":["../src/graph.ts"],"names":[],"mappings":"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","sourcesContent":["import type {\n  AdjacencyStructure,\n  AdjacencyStructureConstructor,\n  TypedArrayConstructors,\n} from \"./utility-types.js\";\nimport { BinaryHeap } from \"./binary-heap.js\";\n\nexport const Colors = {\n  WHITE: 0,\n  GRAY: 1,\n  BLACK: 2,\n} as const;\n\nexport type Colors = typeof Colors[keyof typeof Colors];\n\ntype Vertex = { e: number; w: number };\n\nclass VertexHeap extends BinaryHeap<Vertex> {\n  static compare(a: Vertex, b: Vertex): boolean {\n    return a.w < b.w;\n  }\n}\n\n/**\n * Creates a Graph class extending a given adjacency structure.\n */\nexport function GraphMixin<\n  T extends TypedArrayConstructors,\n  U extends AdjacencyStructureConstructor<T>,\n>(Base: U) {\n  // deno-lint-ignore no-empty-interface\n  interface Graph extends AdjacencyStructure {}\n\n  /**\n   * Extends an adjacency list/matrix structure and provides methods for traversal (BFS, DFS),\n   * pathfinding (Dijkstra, Bellman-Ford), spanning tree construction (BFS, Prim), etc.\n   */\n  class Graph extends Base {\n    _colors?: Uint8Array;\n\n    get colors(): Uint8Array {\n      return (\n        this._colors ||\n        ((this._colors = new Uint8Array(this.vertices)), this._colors)\n      );\n    }\n\n    hasColor(vertex: number, color: Colors): boolean {\n      return this.colors[vertex] === color;\n    }\n\n    /**\n     * Checks whether the graph is acyclic.\n     */\n    isAcyclic(): boolean {\n      for (const vertex of this.traverse(true, 0, false, true)) {\n        if (!this.hasColor(vertex, Colors.WHITE)) return false;\n      }\n      return true;\n    }\n\n    /**\n     * Returns a list of vertices along the shortest path between two given vertices.\n     *\n     * @param start the starting vertex\n     * @param end the ending vertex\n     * @param isAcyclic whether the graph is acyclic\n     * @param isNonNegative whether all edges are non-negative\n     */\n    path(\n      start: number,\n      end: number,\n      isAcyclic = false,\n      isNonNegative = false,\n    ): Array<number> {\n      const { weighted } = this\n        .constructor as AdjacencyStructureConstructor<TypedArrayConstructors>;\n      const { vertices } = this;\n      const predecessors = new Array(vertices).fill(-1);\n      const distances = new Array(vertices).fill(Infinity);\n      const isFound = !weighted\n        ? this.searchUnweighted(start, end, predecessors)\n        : isAcyclic\n        ? this.searchTopological(start, end, distances, predecessors)\n        : isNonNegative\n        ? this.searchDijkstra(start, end, distances, predecessors)\n        : this.searchBellmanFord(start, end, distances, predecessors);\n      if (!isFound) return [];\n      const path = [];\n      let last = end;\n      while (~last) {\n        path.unshift(last);\n        last = predecessors[last];\n      }\n      return path;\n    }\n\n    /**\n     * Resets all coloring of vertices done during traversals.\n     */\n    resetColors(): void {\n      this.colors.fill(0);\n    }\n\n    /**\n     * For all.\n     *\n     * @param start\n     * @param end\n     * @param distances\n     * @param predecessors\n     */\n    searchBellmanFord(\n      start: number,\n      end: number,\n      distances: Array<number>,\n      predecessors: Array<number>,\n    ): boolean {\n      const { vertices } = this;\n      distances[start] = 0;\n      let isFound = false;\n      for (let i = 0; i < vertices; i++) {\n        for (const edge of this.outEdges(i)) {\n          const weight = this.getEdge(i, edge);\n          const distance = distances[i] + weight;\n          if (distances[edge] > distance) {\n            distances[edge] = distance;\n            predecessors[edge] = i;\n            if (edge === end) {\n              isFound = true;\n            }\n          }\n        }\n      }\n      return isFound;\n    }\n\n    /**\n     * For non-negative edges.\n     *\n     * @param start\n     * @param end\n     * @param distances\n     * @param predecessors\n     */\n    searchDijkstra(\n      start: number,\n      end: number,\n      distances: Array<number>,\n      predecessors: Array<number>,\n    ): boolean {\n      this.resetColors();\n      const heap = new VertexHeap();\n      distances[start] = 0;\n      heap.push({ e: start, w: this[start] });\n      let isFound = false;\n      while (heap.length) {\n        const vertex = heap.shift()!;\n        if (this.hasColor(vertex.e, Colors.GRAY)) continue;\n        this.setColor(vertex.e, Colors.GRAY);\n        for (const edge of this.outEdges(vertex.e)) {\n          const weight = this.getEdge(vertex.e, edge);\n          const distance = distances[vertex.e] + weight;\n          if (distance < distances[edge]) {\n            distances[edge] = distance;\n            predecessors[edge] = vertex.e;\n            heap.push({ e: edge, w: distance });\n          }\n          if (edge === end) {\n            isFound = true;\n          }\n        }\n      }\n      return isFound;\n    }\n\n    /**\n     * For DAGs only.\n     *\n     * @param start\n     * @param end\n     * @param distances\n     * @param predecessors\n     */\n    searchTopological(\n      start: number,\n      end: number,\n      distances: Array<number>,\n      predecessors: Array<number>,\n    ): boolean {\n      distances[start] = 0;\n      let lastPredecessor = start;\n      let isFound = false;\n      for (const vertex of this.traverse(true, start, true, true)) {\n        if (!this.hasColor(vertex, Colors.GRAY)) {\n          const weight = this.getEdge(lastPredecessor, vertex);\n          if (distances[vertex] > distances[lastPredecessor] + weight) {\n            distances[vertex] = distances[lastPredecessor] + weight;\n            predecessors[vertex] = lastPredecessor;\n          }\n        } else if (!this.hasColor(vertex, Colors.BLACK)) {\n          lastPredecessor = vertex;\n        }\n        if (vertex === end) {\n          isFound = true;\n        }\n      }\n      return isFound;\n    }\n\n    /**\n     * For unweighted graphs.\n     *\n     * @param start the starting vertex\n     * @param end the ending vertex\n     * @param predecessors\n     */\n    searchUnweighted(\n      start: number,\n      end: number | undefined,\n      predecessors: Array<number>,\n    ): boolean {\n      let lastPredecessor = start;\n      let isFound = false;\n      for (const vertex of this.traverse(false, start, true, true)) {\n        if (this.hasColor(vertex, Colors.BLACK)) continue;\n        if (this.hasColor(vertex, Colors.WHITE)) {\n          predecessors[vertex] = lastPredecessor;\n        } else {\n          lastPredecessor = vertex;\n        }\n        if (vertex === end) {\n          isFound = true;\n          break;\n        }\n      }\n      return isFound;\n    }\n\n    setColor(vertex: number, color: Colors): void {\n      this.colors[vertex] = color;\n    }\n\n    /**\n     * Returns a list of vertexes sorted topologically.\n     */\n    topologicalSort(): Array<number> {\n      const result: Array<number> = [];\n      for (const vertex of this.traverse(true, 0, false, false, true)) {\n        result.unshift(vertex);\n      }\n      return result;\n    }\n\n    /**\n     * Does a Breadth-First or Depth-First traversal of the graph.\n     *\n     * @param isDFS whether to do DFS traversal, does BFS otherwise\n     * @param start the vertex to start at\n     * @param gray whether to return vertices upon entering\n     * @param white whether to return edges upon first encountering\n     * @param black whether to return vertices after processing\n     * @return the vertex at each step\n     */\n    *traverse(\n      isDFS = false,\n      start = 0,\n      gray = true,\n      white = false,\n      black = false,\n    ) {\n      this.resetColors();\n      const processing = [start];\n      const [push, pull]: Array<keyof Array<number>> = isDFS\n        ? [\"push\", \"pop\"]\n        : [\"push\", \"shift\"];\n      while (processing.length) {\n        const vertex = processing[pull]()!;\n        this.setColor(vertex, Colors.GRAY);\n        if (gray) yield vertex;\n        for (const edge of this.outEdges(vertex)) {\n          if (this.hasColor(edge, Colors.WHITE)) {\n            processing[push](edge);\n          }\n          if (white) yield edge;\n        }\n        this.setColor(vertex, Colors.BLACK);\n        if (black) yield vertex;\n      }\n    }\n\n    /**\n     * Returns a minimal spanning tree of the graph.\n     * Uses the Prim's algorithm for weighted graphs and BFS tree for unweighted graphs.\n     *\n     * @param start\n     */\n    tree(start = 0) {\n      const { weighted } = this\n        .constructor as AdjacencyStructureConstructor<TypedArrayConstructors>;\n      const { vertices } = this;\n      const predecessors = new Array(vertices).fill(-1);\n      if (!weighted) {\n        this.searchUnweighted(start, undefined, predecessors);\n        return predecessors;\n      }\n      this.resetColors();\n      const distances = new Array(vertices).fill(Infinity);\n      const heap = new VertexHeap();\n      distances[start] = 0;\n      heap.push({ e: start, w: this[0] });\n      while (heap.length) {\n        const vertex = heap.shift()!;\n        if (this.hasColor(vertex.e, Colors.GRAY)) continue;\n        this.setColor(vertex.e, Colors.GRAY);\n        for (const edge of this.outEdges(vertex.e)) {\n          const weight = this.getEdge(vertex.e, edge);\n          if (this.hasColor(edge, Colors.GRAY) || weight > distances[edge]) {\n            continue;\n          }\n          distances[edge] = weight;\n          predecessors[edge] = vertex.e;\n          heap.push({ e: edge, w: weight });\n        }\n      }\n      return predecessors;\n    }\n  }\n\n  return Graph;\n}\n"]}