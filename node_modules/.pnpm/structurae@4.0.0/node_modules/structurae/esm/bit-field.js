import { getBitSize } from "./utilities.js";
const SIGN_BIT = 2147483647;
const MAX_BITWISE_SIZE = 31;
class BitField {
    constructor(data = 0) {
        Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        this.value = typeof data === "number"
            ? data
            : data instanceof BitField
                ? data.valueOf()
                : this.constructor.encode(data);
    }
    static decode(data) {
        const schema = this.schema;
        const fields = this.fields;
        const masks = this.masks;
        const result = {};
        let value = data;
        for (let i = 0; i < fields.length; i++) {
            const field = fields[i];
            const size = schema[field];
            result[field] = value & masks[field];
            value >>= size;
        }
        return result;
    }
    static encode(data) {
        const schema = this.schema;
        const fields = this.fields;
        const array = Array.isArray(data)
            ? data
            : fields.map((name) => data[name] || 0);
        let result = 0;
        for (let i = fields.length - 1; i >= 0; i--) {
            const field = fields[i];
            const current = array[i];
            result <<= schema[field];
            result |= current;
        }
        return result;
    }
    static getMatcher(matcher) {
        const masks = this.masks;
        const offsets = this.offsets;
        const fields = Object.keys(matcher);
        let mask = 0;
        let value = 0;
        for (let i = 0; i < fields.length; i++) {
            const fieldName = fields[i];
            const fieldMask = masks[fieldName] << offsets[fieldName];
            const fieldValue = matcher[fieldName];
            value = (value & ~fieldMask) | (fieldValue << offsets[fieldName]);
            mask |= fieldMask;
        }
        return [value, this.mask ^ mask];
    }
    static getMinSize(number) {
        return getBitSize(number);
    }
    static isValid(data) {
        const masks = this.masks;
        const fields = Object.keys(data);
        for (let i = 0; i < fields.length; i++) {
            const field = fields[i];
            const value = data[field];
            if ((value & SIGN_BIT) !== value || value > masks[field])
                return false;
        }
        return true;
    }
    static match(value, matcher) {
        return (value & matcher[1]) === matcher[0];
    }
    *[Symbol.iterator]() {
        const fields = this.constructor.fields;
        for (let i = 0; i < fields.length; i++) {
            yield this.get(fields[i]);
        }
    }
    get(field) {
        const { offsets, masks } = this.constructor;
        return (this.value >> offsets[field]) & masks[field];
    }
    has(...fields) {
        const { offsets } = this.constructor;
        let mask = 0;
        for (let i = 0; i < fields.length; i++) {
            mask |= 1 << offsets[fields[i]];
        }
        mask |= this.value;
        return this.value === mask;
    }
    match(matcher) {
        return this.constructor.match(this.value, Array.isArray(matcher)
            ? matcher
            : this.constructor.getMatcher(matcher));
    }
    set(field, value = 1) {
        const { offsets, masks } = this.constructor;
        this.value = (this.value & ~(masks[field] << offsets[field])) |
            (value << offsets[field]);
        return this;
    }
    toJSON() {
        return this.value;
    }
    toObject() {
        return this.constructor.decode(this.value);
    }
    toString() {
        return this.value.toString();
    }
    valueOf() {
        return this.value;
    }
}
Object.defineProperty(BitField, "mask", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 2 << 30
});
Object.defineProperty(BitField, "size", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 31
});
/**
 * Creates a BitField class from with a given schema. BitField uses numbers as bitfields
 * to store and operate on data using bitwise operations. The size of the field is limited to 31 bits,
 * for a larger bitfields consider using BigBitField class that uses bigints instead.
 *
 * @param schema the schema
 * @returns the BitFieldClass
 *
 * @example
 * const Field = BitFieldMixin({ width: 8, height: 8 });
 * const field = new Field({ width: 100, height: 200 });
 * field.get('width');
 * //=> 100;
 * field.get('height');
 * //=> 200
 * field.set('width', 18);
 * field.get('width');
 * //=> 18
 * field.toObject();
 * //=> { width: 18, height: 200 }
 */
export function BitFieldMixin(schema) {
    var _a;
    const fields = Object.keys(schema);
    const masks = {};
    const offsets = {};
    let lastOffset = 0;
    for (let i = 0; i < fields.length; i++) {
        const field = fields[i];
        const size = schema[field];
        masks[field] = (2 << (size - 1)) - 1;
        offsets[field] = lastOffset;
        lastOffset += size;
    }
    if (lastOffset > MAX_BITWISE_SIZE) {
        throw TypeError("The total size of the bitfield exceeds 31 bits.");
    }
    return _a = class extends BitField {
            constructor() {
                super(...arguments);
                Object.defineProperty(this, "size", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: lastOffset
                });
                Object.defineProperty(this, "mask", {
                    enumerable: true,
                    configurable: true,
                    writable: true,
                    value: 2 << (lastOffset - 1)
                });
            }
        },
        Object.defineProperty(_a, "schema", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: schema
        }),
        Object.defineProperty(_a, "fields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: fields
        }),
        Object.defineProperty(_a, "masks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: masks
        }),
        Object.defineProperty(_a, "offsets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: offsets
        }),
        _a;
}
const _BitField = BitFieldMixin({
    0: 1,
    1: 1,
    2: 1,
    3: 1,
    4: 1,
    5: 1,
    6: 1,
    7: 1,
    8: 1,
    9: 1,
    10: 1,
    11: 1,
    12: 1,
    13: 1,
    14: 1,
    15: 1,
    16: 1,
    17: 1,
    18: 1,
    19: 1,
    20: 1,
    21: 1,
    22: 1,
    23: 1,
    24: 1,
    25: 1,
    26: 1,
    27: 1,
    28: 1,
    29: 1,
    30: 1,
});
export { _BitField as BitField };
//# sourceMappingURL=bit-field.js.map