/**
 * Creates an Adjacency List class extending a given TypedArray class.
 *
 * @param Base a TypedArray class to extend
 */
export function AdjacencyListMixin(Base) {
    /**
     * Implements the Adjacency List data structure for weighted directed graphs.
     */
    class AdjacencyList extends Base {
        // deno-lint-ignore no-explicit-any
        constructor(...args) {
            super(...args);
            Object.defineProperty(this, "vertices", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 2
            });
            Object.defineProperty(this, "edges", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: 4
            });
            Object.defineProperty(this, "empty", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: undefined
            });
            [this.vertices, this.edges] = AdjacencyList.getDimensions(this);
        }
        static get [Symbol.species]() {
            return Base;
        }
        static create(vertices, edges) {
            const length = this.getLength(vertices, edges);
            const list = new this(length);
            list.vertices = vertices;
            list.edges = edges;
            list.setOffsets();
            return list;
        }
        /*
        * Returns the dimensions, vertices and maximum edge count, of an existing AdjacencyList
        */
        static getDimensions(list) {
            let vertices = 0;
            while (list[vertices] <= list[vertices + 1]) {
                vertices++;
            }
            const edges = (list.length - vertices - 1) >> 1;
            return [vertices, edges];
        }
        static getLength(vertices, edges) {
            return vertices + (edges << 1) + 1;
        }
        // TODO document RangeError
        addEdge(x, y, weight) {
            if (this.hasEdge(x, y))
                return this;
            // the list is full
            if (this.isFull())
                throw new RangeError("The list is full.");
            const { vertices } = this;
            // shift values
            for (let i = this[vertices]; i > this[x]; i -= 2) {
                [this[i], this[i + 1], this[i - 1], this[i - 2]] = [
                    this[i - 2],
                    this[i - 1],
                    this[i],
                    this[i + 1],
                ];
            }
            // set edge
            this[this[x]] = y;
            this[this[x] + 1] = weight;
            // update offsets
            for (let i = x + 1; i <= vertices; i++) {
                this[i] += 2;
            }
            return this;
        }
        getEdge(x, y) {
            const offset = this[x];
            const nextOffset = this[x + 1];
            // no out edges from x
            if (offset === nextOffset)
                return NaN;
            for (let i = offset; i < nextOffset; i += 2) {
                if (this[i] === y)
                    return this[i + 1];
            }
            return NaN;
        }
        hasEdge(x, y) {
            return !Number.isNaN(this.getEdge(x, y));
        }
        *inEdges(vertex) {
            const { vertices } = this;
            let edge = 0;
            let nextVertex = 1;
            for (let i = vertices + 1; i < this[vertices]; i += 2) {
                while (i >= this[nextVertex]) {
                    edge++;
                    nextVertex++;
                }
                if (this[i] === vertex)
                    yield edge;
            }
        }
        isFull() {
            return this[this.vertices] >= this.length;
        }
        *outEdges(vertex) {
            const offset = this[vertex];
            const nextOffset = this[vertex + 1];
            if (offset !== nextOffset) {
                for (let i = nextOffset - 2; i >= offset; i -= 2) {
                    yield this[i];
                }
            }
        }
        removeEdge(x, y) {
            const offset = this[x];
            const nextOffset = this[x + 1];
            // no out edges from x
            if (offset === nextOffset)
                return this;
            let edgeIndex = 0;
            for (let i = offset; i < nextOffset; i += 2) {
                if (this[i] === y) {
                    edgeIndex = i;
                    break;
                }
            }
            // there is no such edge
            if (!edgeIndex)
                return this;
            // shift value
            for (let i = edgeIndex; i < this[this.vertices]; i += 2) {
                this[i] = this[i + 2];
                this[i + 1] = this[i + 3];
            }
            // update offsets
            for (let i = x + 1; i <= this.vertices; i++) {
                this[i] -= 2;
            }
            return this;
        }
        setOffsets() {
            const lastElement = this.vertices + 1;
            for (let i = 0; i < lastElement; i++) {
                this[i] = lastElement;
            }
        }
    }
    Object.defineProperty(AdjacencyList, "directed", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
    });
    Object.defineProperty(AdjacencyList, "weighted", {
        enumerable: true,
        configurable: true,
        writable: true,
        value: true
    });
    return AdjacencyList;
}
//# sourceMappingURL=adjacency-list.js.map