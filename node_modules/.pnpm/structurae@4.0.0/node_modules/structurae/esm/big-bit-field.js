import { getBitSize } from "./utilities.js";
const SIGN_BIT = BigInt(2147483647);
const ZERO = BigInt(0);
const ONE = BigInt(1);
const TWO = BigInt(2);
class BigBitField {
    constructor(data = ZERO) {
        Object.defineProperty(this, "value", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: ZERO
        });
        this.value = data instanceof BigBitField
            ? data.valueOf()
            : typeof data === "object"
                ? this.constructor.encode(data)
                : BigInt(data);
    }
    static decode(data) {
        const schema = this.schema;
        const fields = this.fields;
        const masks = this.masks;
        const result = {};
        let value = data;
        for (let i = 0; i < fields.length; i++) {
            const field = fields[i];
            result[field] = Number(value & masks[field]);
            value >>= schema[field];
        }
        return result;
    }
    static encode(data) {
        const schema = this.schema;
        const fields = this.fields;
        const array = Array.isArray(data)
            ? data
            : fields.map((name) => data[name] || 0);
        let result = ZERO;
        for (let i = fields.length - 1; i >= 0; i--) {
            const field = fields[i];
            const current = array[i];
            result <<= schema[field];
            result |= BigInt(current);
        }
        return result;
    }
    static getMatcher(matcher) {
        const { masks, offsets } = this;
        const fields = Object.keys(matcher);
        let mask = ZERO;
        let value = ZERO;
        for (let i = 0; i < fields.length; i++) {
            const fieldName = fields[i];
            const offset = offsets[fieldName];
            const fieldMask = masks[fieldName] << offset;
            const fieldValue = BigInt(matcher[fieldName]);
            value = (value & ~fieldMask) | (fieldValue << offsets[fieldName]);
            mask |= fieldMask;
        }
        return [value, this.mask ^ mask];
    }
    static getMinSize(number) {
        return getBitSize(number);
    }
    static isValid(data) {
        const { masks } = this;
        const fields = Object.keys(data);
        for (let i = 0; i < fields.length; i++) {
            const field = fields[i];
            const value = BigInt(data[field]);
            if ((value & SIGN_BIT) !== value || value > masks[field])
                return false;
        }
        return true;
    }
    static match(value, matcher) {
        return (value & matcher[1]) === matcher[0];
    }
    *[Symbol.iterator]() {
        const { fields } = this.constructor;
        for (let i = 0; i < fields.length; i++) {
            yield this.get(fields[i]);
        }
    }
    get(field) {
        const { offsets, masks } = this.constructor;
        const value = (this.value >> offsets[field]) & masks[field];
        return Number(value);
    }
    has(...fields) {
        const { offsets } = this.constructor;
        let mask = ZERO;
        for (let i = 0; i < fields.length; i++) {
            mask |= ONE << offsets[fields[i]];
        }
        mask |= this.value;
        return this.value === mask;
    }
    match(matcher) {
        return this.constructor.match(this.value, Array.isArray(matcher)
            ? matcher
            : this.constructor.getMatcher(matcher));
    }
    set(field, value = 1) {
        const { offsets, masks } = this.constructor;
        const offset = offsets[field];
        this.value = (this.value & ~(masks[field] << offset)) |
            (BigInt(value) << offsets[field]);
        return this;
    }
    toJSON() {
        return this.value;
    }
    toObject() {
        return this.constructor.decode(this.value);
    }
    toString() {
        return this.value.toString();
    }
    valueOf() {
        return this.value;
    }
}
/**
 * Creates a BigBitField class with a given schema. BigBitField uses bigints as bitfields
 * to store and operate on data using bitwise operations.
 *
 * @param schema the schema
 * @returns the BigBitFieldClass
 *
 * @example
 * const LargeField = BitFieldMixin({ width: 20, height: 20 });
 * const largeField = new LargeField({ width: 1048576, height: 1048576 });
 * largeField.value
 * //=> 1099512676352n
 * largeField.set('width', 1000).get('width')
 * //=> 1000
 * largeField.toObject()
 * //=> { width: 1000, height: 1048576 }
 */
export function BigBitFieldMixin(schema) {
    var _a;
    const fields = Object.keys(schema);
    const _schema = {};
    const masks = {};
    const offsets = {};
    let lastOffset = ZERO;
    for (let i = 0; i < fields.length; i++) {
        const field = fields[i];
        const size = BigInt(schema[field]);
        _schema[field] = size;
        masks[field] = (TWO << (size - ONE)) - ONE;
        offsets[field] = lastOffset;
        lastOffset += size;
    }
    return _a = class extends BigBitField {
        },
        Object.defineProperty(_a, "schema", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: _schema
        }),
        Object.defineProperty(_a, "fields", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: fields
        }),
        Object.defineProperty(_a, "masks", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: masks
        }),
        Object.defineProperty(_a, "offsets", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: offsets
        }),
        Object.defineProperty(_a, "size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: lastOffset
        }),
        Object.defineProperty(_a, "mask", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: TWO << (BigInt(lastOffset) - ONE)
        }),
        _a;
}
//# sourceMappingURL=big-bit-field.js.map