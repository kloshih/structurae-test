import { BooleanView } from "./boolean-view.js";
import { BigInt64View, BigUint64View, Float32View, Float64View, Int16View, Int32View, Int8View, Uint16View, Uint32View, Uint8View, } from "./numeric-view.js";
import { ObjectView } from "./object-view.js";
import { ArrayView } from "./array-view.js";
import { VectorView } from "./vector-view.js";
import { MapView } from "./map-view.js";
import { DictView } from "./dict-view.js";
import { StringView } from "./string-view.js";
import { TypedArrayView } from "./typed-array-view.js";
import { BinaryView } from "./binary-view.js";
import { log2 } from "./utilities.js";
export class View {
    constructor(maxView = new DataView(new ArrayBuffer(8192))) {
        Object.defineProperty(this, "maxView", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: maxView
        });
        Object.defineProperty(this, "Views", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map([
                ["array", ArrayView],
                ["typedarray", TypedArrayView],
                ["vector", VectorView],
                ["object", ObjectView],
                ["map", MapView],
                ["dict", DictView],
                ["int8", Int8View],
                ["uint8", Uint8View],
                ["int16", Int16View],
                ["uint16", Uint16View],
                ["int32", Int32View],
                ["number", Float64View],
                ["integer", Int32View],
                ["uint32", Uint32View],
                ["float32", Float32View],
                ["float64", Float64View],
                ["bigint64", BigInt64View],
                ["biguint64", BigUint64View],
                ["boolean", BooleanView],
                ["string", StringView],
                ["binary", BinaryView],
            ])
        });
        Object.defineProperty(this, "TaggedViews", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: new Map()
        });
    }
    create(schema, constructor) {
        const { getSchemaId, getSchemaOrdering } = this
            .constructor;
        const schemas = getSchemaOrdering(schema);
        for (let i = schemas.length - 1; i >= 0; i--) {
            const objectSchema = schemas[i];
            const id = getSchemaId(objectSchema);
            if (this.Views.has(id))
                continue;
            // use provided constructor for top object
            const objectCtor = objectSchema === schema ? constructor : undefined;
            const View = objectSchema.btype === "map"
                ? this.Views.get("map").initialize(objectSchema, this, objectCtor)
                : objectSchema.btype === "dict"
                    ? this.Views.get("dict").initialize(objectSchema, this)
                    : this.Views.get("object").initialize(objectSchema, this, objectCtor);
            // cache the view by id
            this.Views.set(id, View);
            // cache by tag if present
            const tag = this.getSchemaTag(objectSchema);
            if (tag)
                this.TaggedViews.set(tag, View);
        }
        if (schema.type === "array")
            return this.getArray(schema)[0];
        return this.getExistingView(schema);
    }
    view(view) {
        const tag = this.getTag(view);
        const ViewClass = this.TaggedViews.get(tag);
        if (!ViewClass)
            return undefined;
        return new ViewClass(view.buffer, view.byteOffset);
    }
    decode(view) {
        const tag = this.getTag(view);
        const ViewClass = this.TaggedViews.get(tag);
        if (!ViewClass)
            return undefined;
        return ViewClass.decode(view, 0);
    }
    encode(value, view, offset = 0) {
        const ViewClass = this.TaggedViews.get(value.tag);
        if (!ViewClass)
            return undefined;
        if (!view)
            return ViewClass.from(value);
        ViewClass.encode(value, view, offset);
        return new ViewClass(view.buffer, view.byteOffset);
    }
    getTag(view) {
        return view.getUint8(0);
    }
    getSchemaTag(schema) {
        const tag = schema.properties?.tag
            ?.default;
        return typeof tag === "number" ? tag : undefined;
    }
    getArray(schema) {
        const { getSchemaId } = this.constructor;
        const arrays = [];
        let currentField = schema;
        // go down the array(s) to the item field
        while (currentField && currentField.type === "array") {
            arrays.push(currentField);
            currentField = currentField.items;
        }
        let currentArray = arrays.pop();
        // get existing view of the item
        const itemView = this.getExistingView(currentField);
        // check
        const itemId = getSchemaId(currentField);
        const isArray = currentArray.btype !== "vector";
        const viewId = isArray ? `ArrayView_${itemId}` : `VectorView_${itemId}`;
        let CurrentView;
        if (!this.Views.has(viewId)) {
            CurrentView = isArray
                ? this.getArrayView(currentField, itemView, currentField.maxLength)
                : this.Views.get("vector").initialize(currentField, this, itemView);
            // cache array views of unspecified length
            if (currentField.maxLength === undefined) {
                this.Views.set(viewId, CurrentView);
            }
        }
        else {
            CurrentView = this.Views.get(viewId);
        }
        // initialize nested arrays
        let itemLength = isArray ? CurrentView.getLength(currentArray.maxItems) : 0;
        for (let i = arrays.length - 1; i >= 0; i--) {
            currentArray = arrays[i];
            if (currentArray.btype !== "vector") {
                CurrentView = this.getArrayView(currentArray.items, CurrentView, itemLength);
                itemLength = CurrentView.getLength(currentArray.maxItems);
            }
            else {
                CurrentView = this.Views.get("vector").initialize(currentArray.items, this, CurrentView);
            }
        }
        return [CurrentView, itemLength];
    }
    getArrayView(schema, SchemaView, length) {
        const itemLength = length || SchemaView?.viewLength;
        const isTypedArray = Reflect.has(log2, itemLength);
        return this.Views.get(isTypedArray ? "typedarray" : "array")
            .initialize(schema, this, SchemaView, itemLength);
    }
    static getDefaultData(layout, viewLength, fields) {
        const buffer = new ArrayBuffer(viewLength);
        const view = new DataView(buffer);
        const array = new Uint8Array(buffer);
        for (const name of fields) {
            const field = layout[name];
            if (Reflect.has(field, "default")) {
                field.View.encode(field.default, view, field.start, field.length);
            }
            else if (field.View.defaultData) {
                array.set(field.View.defaultData, field.start);
            }
        }
        return array;
    }
    static getDefaultConstructor(fields, layout) {
        const content = [];
        for (const field of fields) {
            const View = layout[field].View;
            let value = "";
            switch (View) {
                case Int8View:
                case Int16View:
                case Uint16View:
                case Uint8View:
                case Int32View:
                    value = "0";
                    break;
                case Float32View:
                case Float64View:
                    value = "0.0";
                    break;
                case BigInt64View:
                case BigUint64View:
                    value = "0n";
                    break;
                case BooleanView:
                    value = "false";
                    break;
                case StringView:
                    value = "''";
                    break;
                default:
                    value = "null";
            }
            content.push(`${field}:${value}`);
        }
        return new Function("return {" + content.join(",") +
            "}");
    }
    getExistingView(schema) {
        const { AbstractViews } = this.constructor;
        let type = schema.$id || schema.$ref?.slice(1);
        if (type) {
            if (!this.Views.has(type))
                throw Error(`View "${type}" is not found.`);
        }
        else {
            type = schema.btype || schema.type;
            if (!this.Views.has(type)) {
                throw TypeError(`Type "${type}" is not supported.`);
            }
            else if (AbstractViews.has(type)) {
                throw TypeError(`Type ${type} is abstract.`);
            }
        }
        return this.Views.get(type);
    }
    getFieldLayout(field, start, required, name) {
        let View;
        let length = 0;
        if (field.type !== "array") {
            View = this.getExistingView(field);
            length = field.maxLength || View.viewLength;
        }
        else {
            [View, length] = this.getArray(field);
        }
        if (!length)
            length = Infinity;
        if (required && length === Infinity) {
            throw new TypeError(`The length of a required field "${name}" is undefined.`);
        }
        const layout = { start, View, length, required };
        if (Reflect.has(field, "default")) {
            layout.default = field.default;
        }
        return layout;
    }
    // deno-lint-ignore no-explicit-any
    static getSchemaId(schema) {
        return schema.$id || schema.$ref?.slice(1) || schema.btype || schema.type;
    }
    static getSchemaOrdering(schema) {
        // create graph
        let object = schema;
        // reach the nested object if an array is provided
        while (object.type === "array")
            object = object.items;
        // return if no object found
        if (object.type !== "object")
            return [];
        const mainId = object.$id;
        let id = mainId;
        const objects = { [id]: object };
        const adjacency = { [id]: [] };
        const indegrees = { [id]: 0 };
        const processing = [id];
        while (processing.length) {
            id = processing.pop();
            object = objects[id];
            if (!object.properties)
                continue;
            const properties = Object.keys(object.properties);
            for (const property of properties) {
                let field = object.properties[property];
                if (field.type === "array") {
                    while (field.type === "array")
                        field = field.items;
                }
                const { $id, $ref } = field;
                if ($id) {
                    objects[$id] = field;
                    adjacency[id].push($id);
                    adjacency[$id] = [];
                    indegrees[$id] = indegrees[$id] ? indegrees[$id] + 1 : 1;
                    processing.push($id);
                }
                else if ($ref) {
                    const refId = $ref.slice(1);
                    indegrees[refId] = indegrees[refId] ? indegrees[refId] + 1 : 1;
                    adjacency[id].push(refId);
                }
            }
        }
        // topologically sort the graph
        let visited = 0;
        const order = [];
        processing.push(mainId);
        while (processing.length) {
            id = processing.shift();
            const children = adjacency[id];
            if (!children)
                continue; // $ref no external links
            order.push(objects[id]);
            for (const child of children) {
                indegrees[child] -= 1;
                if (indegrees[child] === 0)
                    processing.push(child);
            }
            visited++;
        }
        // check for recursive links
        if (visited !== Object.keys(objects).length) {
            throw TypeError("The schema has recursive references.");
        }
        return order;
    }
}
Object.defineProperty(View, "AbstractViews", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: new Set([
        "object",
        "array",
        "typedarray",
        "vector",
        "map",
        "dict",
    ])
});
//# sourceMappingURL=view.js.map