export class MapView extends DataView {
    static decode(view, start = 0) {
        const fields = this.fields;
        const layout = this.layout;
        const optionalFields = this.optionalFields;
        const object = new this.ObjectConstructor();
        for (let i = 0; i < fields.length; i++) {
            const field = fields[i];
            const { View, start: startOffset, length } = layout[field];
            object[field] = View.decode(view, start + startOffset, length);
        }
        for (let i = 0; i < optionalFields.length; i++) {
            const field = optionalFields[i];
            const { View, start: startOffset } = layout[field];
            const fieldStart = view.getUint32(start + startOffset, true);
            const end = view.getUint32(start + startOffset + 4, true);
            if (fieldStart === end)
                continue;
            object[field] = View.decode(view, start + fieldStart, end - fieldStart);
        }
        return object;
    }
    static encode(value, view, start = 0, length, amend) {
        const fields = this.fields;
        const layout = this.layout;
        const optionalFields = this.optionalFields;
        // zero-out required part if encode is called internally providing length
        if (!amend) {
            new Uint8Array(view.buffer, view.byteOffset + start, this.optionalOffset).fill(0);
        }
        for (const field of fields) {
            const fieldValue = value[field];
            if (fieldValue != null) {
                const { View, length: maxLength, start: fieldStart } = layout[field];
                View.encode(fieldValue, view, start + fieldStart, maxLength);
            }
        }
        let end = this.lengthOffset + 4;
        let availableSpace = (length ?? view.byteLength) - end;
        for (const field of optionalFields) {
            const fieldValue = value[field];
            const { View, length: maxLayoutLength, start: fieldStart } = layout[field];
            view.setUint32(start + fieldStart, end, true);
            let fieldLength = 0;
            if (fieldValue != null) {
                const caret = start + end;
                if (View.viewLength || View.itemLength) {
                    fieldLength = View.getLength(fieldValue.length || 1);
                    if (fieldLength > availableSpace)
                        continue;
                    View.encode(fieldValue, view, caret, fieldLength);
                }
                else {
                    // support setting max length for optional strings
                    const maxLength = length
                        ? Math.min(availableSpace, maxLayoutLength)
                        : maxLayoutLength !== Infinity
                            ? maxLayoutLength
                            : undefined;
                    fieldLength = View.encode(fieldValue, view, caret, maxLength);
                }
                end += fieldLength;
                availableSpace -= fieldLength;
            }
        }
        view.setUint32(start + this.lengthOffset, end, true);
        return end;
    }
    static from(value) {
        const { maxView, defaultData } = this;
        const mapArray = new Uint8Array(maxView.buffer, maxView.byteOffset);
        if (defaultData) {
            mapArray.set(defaultData);
        }
        const end = this.encode(value, maxView, 0, undefined, true);
        return new this(maxView.buffer.slice(0, end));
    }
    static getLength(value) {
        const layout = this.layout;
        const optionalFields = this.optionalFields;
        let length = this.lengthOffset + 4;
        for (let i = 0; i < optionalFields.length; i++) {
            const field = optionalFields[i];
            const fieldValue = value[field];
            if (fieldValue == null)
                continue;
            let fieldLength = 0;
            const { View, length: maxLength } = layout[field];
            if (View.viewLength) {
                fieldLength = View.viewLength;
            }
            else if (View.itemLength) {
                fieldLength = View.getLength(fieldValue.length);
            }
            else {
                fieldLength = View.getLength(fieldValue);
            }
            length += Math.min(fieldLength, maxLength);
        }
        return length;
    }
    get(field) {
        const layout = this.getLayout(field);
        if (!layout)
            return undefined;
        const [View, start, length] = layout;
        return View.decode(this, start, length);
    }
    getLength(field) {
        const layout = this.getLayout(field);
        if (!layout)
            return 0;
        return layout[2];
    }
    getLayout(field) {
        const layout = this.constructor.layout;
        const definition = layout[field];
        if (!definition)
            return undefined;
        const { View, start, required, length } = definition;
        if (required) {
            return [View, start, length];
        }
        const startOffset = this.getUint32(start, true);
        const end = this.getUint32(start + 4, true);
        if (startOffset === end)
            return undefined;
        return [View, startOffset, end - startOffset];
    }
    getView(field) {
        const layout = this.getLayout(field);
        if (!layout)
            return undefined;
        const [View, start, length] = layout;
        return new View(this.buffer, start, length);
    }
    set(field, value) {
        const layout = this.getLayout(field);
        if (!layout)
            return undefined;
        const [View, start, length] = layout;
        View.encode(value, this, this.byteOffset + start, length);
        return undefined;
    }
    setView(field, view) {
        const layout = this.getLayout(field);
        if (!layout)
            return undefined;
        new Uint8Array(this.buffer, this.byteOffset, this.byteLength).set(new Uint8Array(view.buffer, view.byteOffset, view.byteLength), layout[1]);
        return undefined;
    }
    toJSON() {
        return this.constructor.decode(this);
    }
    static initialize(schema, Factory, constructor) {
        var _a;
        const { getDefaultConstructor, getDefaultData } = Factory
            .constructor;
        const required = schema.required || [];
        const optional = Object.keys(schema.properties).filter((i) => !required.includes(i));
        const layout = {};
        let offset = 0;
        for (const property of required) {
            const field = schema.properties[property];
            const fieldLayout = Factory.getFieldLayout(field, offset, true, property);
            offset += fieldLayout.length;
            layout[property] = fieldLayout;
        }
        const optionalOffset = offset;
        for (let i = 0; i < optional.length; i++) {
            const property = optional[i];
            const field = schema.properties[property];
            layout[property] = Factory.getFieldLayout(field, offset + (i << 2), false, property);
        }
        const defaultData = getDefaultData(layout, optionalOffset, required);
        const ObjectConstructor = constructor ||
            getDefaultConstructor(required, layout);
        return _a = class extends this {
            },
            Object.defineProperty(_a, "layout", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: layout
            }),
            Object.defineProperty(_a, "lengthOffset", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: optionalOffset + (optional.length << 2)
            }),
            Object.defineProperty(_a, "optionalOffset", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: optionalOffset
            }),
            Object.defineProperty(_a, "fields", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: required
            }),
            Object.defineProperty(_a, "optionalFields", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: optional
            }),
            Object.defineProperty(_a, "maxView", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: Factory.maxView
            }),
            Object.defineProperty(_a, "defaultData", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: defaultData
            }),
            Object.defineProperty(_a, "ObjectConstructor", {
                enumerable: true,
                configurable: true,
                writable: true,
                value: ObjectConstructor
            }),
            _a;
    }
}
Object.defineProperty(MapView, "viewLength", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: 0
});
//# sourceMappingURL=map-view.js.map