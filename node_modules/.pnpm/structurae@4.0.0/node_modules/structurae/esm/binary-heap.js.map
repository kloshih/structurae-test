{"version":3,"file":"binary-heap.js","sourceRoot":"","sources":["../src/binary-heap.ts"],"names":[],"mappings":"AAAA;;;;GAIG;AACH,MAAM,OAAO,UAAc,SAAQ,KAAQ;IACzC,mCAAmC;IACnC,YAAY,GAAG,IAAW;QACxB,KAAK,CAAC,GAAG,IAAI,CAAC,CAAC;QACf,IAAI,CAAC,OAAO,EAAE,CAAC;IACjB,CAAC;IAED,MAAM,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC;QACzB,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;;;;;OAMG;IACH,MAAM,CAAC,OAAO,CAAC,CAAU,EAAE,CAAU;QACnC,OAAgB,CAAC,GAAY,CAAC,CAAC;IACjC,CAAC;IAMD,MAAM,CAAC,IAAI,CACT,QAAoC,EACpC,KAA8B,EAC9B,OAAiB;QAEjB,OAAQ,CAAC,KAAK,KAAK,SAAS;YAC1B,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,EAAE,KAAK,EAAE,OAAO,CAAC;YACtC,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAmB,CAAC,OAAO,EAAE,CAAC;IACxD,CAAC;IAED;;;;;OAKG;IACH,MAAM,CAAC,YAAY,CAAC,KAAa;QAC/B,OAAO,CAAC,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;IAC1B,CAAC;IAED;;;;;OAKG;IACH,MAAM,CAAC,cAAc,CAAC,KAAa;QACjC,OAAO,CAAC,KAAK,GAAG,CAAC,CAAC,IAAI,CAAC,CAAC;IAC1B,CAAC;IAED;;;;;OAKG;IACH,MAAM,CAAC,aAAa,CAAC,KAAa;QAChC,OAAO,CAAC,KAAK,IAAI,CAAC,CAAC,GAAG,CAAC,CAAC;IAC1B,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,MAAM,CAAI,IAAkB;QACjC,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,EAAE;YACzC,MAAM,WAAW,GAAG,IAAI,CAAC,cAAc,CAAC,CAAC,CAAC,CAAC;YAC3C,IAAI,WAAW,GAAG,CAAC;gBAAE,MAAM;YAC3B,IAAI,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC,CAAC;gBAAE,OAAO,KAAK,CAAC;SAC7D;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;;;;;OAMG;IACH,MAAM,CAAC,EAAE,CAAI,GAAG,QAAkB;QAChC,OAAQ,KAAK,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAmB,CAAC,OAAO,EAAE,CAAC;IAC5D,CAAC;IAED;;OAEG;IACH,GAAG,CAAC,KAAa;QACf,OAAO,KAAK,IAAI,CAAC,IAAI,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC;IAC3C,CAAC;IAED;;OAEG;IACH,OAAO;QACL,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,IAAI,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE;YAC1C,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;SAClB;QACD,OAAO,IAAI,CAAC;IACd,CAAC;IAED;;OAEG;IACH,MAAM;QACJ,OAAQ,IAAI,CAAC,WAAiC,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IAC9D,CAAC;IAED;;OAEG;IACH,IAAI,CAAC,KAAa;QAChB,OAAO,IAAI,CAAE,IAAI,CAAC,WAAiC,CAAC,YAAY,CAAC,KAAK,CAAC,CAAC,CAAC;IAC3E,CAAC;IAED;;OAEG;IACH,MAAM,CAAC,KAAa;QAClB,OAAO,IAAI,CAAE,IAAI,CAAC,WAAiC,CAAC,cAAc,CAAC,KAAK,CAAC,CAAC,CAAC;IAC7E,CAAC;IAED;;;;;OAKG;IACH,IAAI,CAAC,GAAG,QAAkB;QACxB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,QAAQ,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YACxC,KAAK,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,CAAC;YACxB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC;SAC9B;QACD,OAAO,IAAI,CAAC,MAAM,CAAC;IACrB,CAAC;IAED;;;;;OAKG;IACH,OAAO,CAAC,OAAU;QAChB,MAAM,KAAK,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;QACtB,IAAI,CAAC,CAAC,CAAC,GAAG,OAAO,CAAC;QAClB,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;QACjB,OAAO,KAAK,CAAC;IACf,CAAC;IAED;;OAEG;IACH,KAAK,CAAC,KAAa;QACjB,OAAO,IAAI,CAAE,IAAI,CAAC,WAAiC,CAAC,aAAa,CAAC,KAAK,CAAC,CAAC,CAAC;IAC5E,CAAC;IAED;;OAEG;IACH,KAAK;QACH,kBAAkB;QAClB,IAAI,IAAI,CAAC,MAAM,GAAG,CAAC;YAAE,OAAO,IAAI,CAAC,GAAG,EAAE,CAAC;QACvC,MAAM,IAAI,GAAG,IAAI,CAAC,CAAC,CAAC,CAAC;QACrB,IAAI,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC,GAAG,EAAO,CAAC;QAC1B,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC;QACjB,OAAO,IAAI,CAAC;IACd,CAAC;IAED,QAAQ,CAAC,KAAa;QACpB,MAAM,EAAE,aAAa,EAAE,YAAY,EAAE,OAAO,EAAE,GAAG,IAAI;aAClD,WAAgC,CAAC;QACpC,IAAI,KAAK,GAAG,KAAK,CAAC;QAClB,IAAI,SAAS,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC;QACpC,IAAI,UAAU,GAAG,aAAa,CAAC,KAAK,CAAC,CAAC;QACtC,IAAI,SAAS,CAAC;QACd,OAAO,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;YAC1B,IAAI,IAAI,CAAC,GAAG,CAAC,UAAU,CAAC,IAAI,OAAO,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,EAAE;gBACtE,SAAS,GAAG,UAAU,CAAC;aACxB;iBAAM;gBACL,SAAS,GAAG,SAAS,CAAC;aACvB;YAED,IAAI,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC;gBAAE,MAAM;YACjD,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,SAAS,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;YAChE,KAAK,GAAG,SAAS,CAAC;YAClB,SAAS,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC;YAChC,UAAU,GAAG,aAAa,CAAC,KAAK,CAAC,CAAC;SACnC;IACH,CAAC;IAED,MAAM,CAAC,KAAa;QAClB,MAAM,EAAE,cAAc,EAAE,OAAO,EAAE,GAAG,IAAI,CAAC,WAAgC,CAAC;QAC1E,IAAI,KAAK,GAAG,KAAK,CAAC;QAClB,IAAI,WAAW,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC;QACxC,OAAO,IAAI,CAAC,GAAG,CAAC,WAAW,CAAC,IAAI,CAAC,OAAO,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE;YACxE,CAAC,IAAI,CAAC,KAAK,CAAC,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,WAAW,CAAC,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;YACpE,KAAK,GAAG,WAAW,CAAC;YACpB,WAAW,GAAG,cAAc,CAAC,KAAK,CAAC,CAAC;SACrC;IACH,CAAC;IAED;;;;;;;OAOG;IACH,MAAM,CAAC,KAAa,EAAE,WAAoB,EAAE,GAAG,KAAe;QAC5D,MAAM,YAAY,GAAG,WAAW,KAAK,SAAS;YAC5C,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC;YACrB,CAAC,CAAC,KAAK,CAAC,MAAM,CAAC,KAAK,EAAE,WAAW,EAAE,GAAG,KAAK,CAAC,CAAC;QAC/C,MAAM,QAAQ,GAAG,YAAY,CAAC,MAAM,GAAG,CAAC,IAAI,KAAK,CAAC,MAAM,GAAG,CAAC,CAAC;QAC7D,IAAI,QAAQ,EAAE;YACZ,MAAM,KAAK,GAAG,KAAK,CAAC;YACpB,MAAM,aAAa,GAAG,KAAK,CAAC,MAAM,KAAK,CAAC,CAAC;YACzC,IAAI,aAAa,EAAE;gBACjB,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;aACpB;iBAAM;gBACL,MAAM,IAAI,GAAG,IAAI,CAAC,GAAG,EAAE,CAAC;gBACxB,KAAK,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC,EAAE,IAAS,CAAC,CAAC;gBAClC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;aACtB;SACF;aAAM;YACL,IAAI,CAAC,OAAO,EAAE,CAAC;SAChB;QACD,OAAO,YAAY,CAAC;IACtB,CAAC;IAED;;;;;OAKG;IACH,OAAO,CAAC,GAAG,KAAe;QACxB,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,KAAK,CAAC,CAAC;IAC7B,CAAC;IAED;;;;OAIG;IACH,MAAM,CAAC,KAAa;QAClB,MAAM,EAAE,OAAO,EAAE,YAAY,EAAE,GAAG,IAAI,CAAC,WAAgC,CAAC;QACxE,MAAM,MAAM,GAAG,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;QAClC,MAAM,SAAS,GAAG,YAAY,CAAC,KAAK,CAAC,CAAC;QACtC,IACE,IAAI,CAAC,GAAG,CAAC,SAAS,CAAC;YACnB,CAAC,MAAM,KAAK,SAAS,IAAI,OAAO,CAAC,MAAM,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,EACtD;YACA,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC;SACtB;aAAM;YACL,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;SACpB;IACH,CAAC;CACF","sourcesContent":["/**\n * Extends Array to implement the Binary Heap data structure.\n * // TODO (docs) document priority queue operations\n * // todo add heapsort?\n */\nexport class BinaryHeap<T> extends Array<T> {\n  // deno-lint-ignore no-explicit-any\n  constructor(...args: any[]) {\n    super(...args);\n    this.heapify();\n  }\n\n  static get [Symbol.species](): ArrayConstructor {\n    return Array;\n  }\n\n  /**\n   * The comparator function used by the heap.\n   *\n   * @param a first value to compare\n   * @param b second value to compare\n   * @return whether first value is less than the second\n   */\n  static compare(a: unknown, b: unknown): boolean {\n    return <number> a < <number> b;\n  }\n\n  /**\n   * Creates a new BinaryHeap from a given array-like object.\n   */\n  static from<T>(iterable: Iterable<T> | ArrayLike<T>): BinaryHeap<T>;\n  static from<T, U>(\n    iterable: Iterable<T> | ArrayLike<T>,\n    mapfn?: (v: T, k: number) => U,\n    thisArg?: unknown,\n  ): BinaryHeap<U> {\n    return ((mapfn !== undefined\n      ? super.from(iterable, mapfn, thisArg)\n      : super.from(iterable)) as BinaryHeap<U>).heapify();\n  }\n\n  /**\n   * Get left child index from parent index.\n   *\n   * @param index the parent index\n   * @return the index of the left child\n   */\n  static getLeftIndex(index: number): number {\n    return (index << 1) + 1;\n  }\n\n  /**\n   * Get left child index from parent index.\n   *\n   * @param index the child index\n   * @return the index of the parent\n   */\n  static getParentIndex(index: number): number {\n    return (index - 1) >> 1;\n  }\n\n  /**\n   * Get right child index from parent index.\n   *\n   * @param index the parent index\n   * @return the index of the right child\n   */\n  static getRightIndex(index: number): number {\n    return (index << 1) + 2;\n  }\n\n  /**\n   * Checks if a given collection is a valid binary heap.\n   */\n  static isHeap<T>(heap: ArrayLike<T>): boolean {\n    for (let i = heap.length - 1; i > -1; i--) {\n      const parentIndex = this.getParentIndex(i);\n      if (parentIndex < 0) break;\n      if (!this.compare(heap[parentIndex], heap[i])) return false;\n    }\n    return true;\n  }\n\n  /**\n   * Creates a new BinaryHeap with a variable number of arguments,\n   * regardless of number or type of the arguments.\n   *\n   * @param elements the elements of which to create the heap\n   * @return the new BinaryHeap\n   */\n  static of<T>(...elements: Array<T>): BinaryHeap<T> {\n    return (super.of(...elements) as BinaryHeap<T>).heapify();\n  }\n\n  /**\n   * Check whether the index is whithin the heap.\n   */\n  has(index: number): boolean {\n    return index >= 0 && index < this.length;\n  }\n\n  /**\n   * Restores the binary heap.\n   */\n  heapify(): this {\n    for (let i = this.length >> 1; i >= 0; i--) {\n      this.siftDown(i);\n    }\n    return this;\n  }\n\n  /**\n   * Checks whether the array is a valid binary heap.\n   */\n  isHeap(): boolean {\n    return (this.constructor as typeof BinaryHeap).isHeap(this);\n  }\n\n  /**\n   * Returns the left child of an element at a given index.\n   */\n  left(index: number): T {\n    return this[(this.constructor as typeof BinaryHeap).getLeftIndex(index)];\n  }\n\n  /**\n   * Returns the parent of an element at a given index.\n   */\n  parent(index: number): T {\n    return this[(this.constructor as typeof BinaryHeap).getParentIndex(index)];\n  }\n\n  /**\n   * Adds items to the heap.\n   *\n   * @param elements items to add\n   * @return new length of the heap\n   */\n  push(...elements: Array<T>): number {\n    for (let i = 0; i < elements.length; i++) {\n      super.push(elements[i]);\n      this.siftUp(this.length - 1);\n    }\n    return this.length;\n  }\n\n  /**\n   * Returns the first (min/max) element of the heap and replaces it with a given element.\n   *\n   * @param element the element to replace the first element of the heap\n   * @return the first element of the heap\n   */\n  replace(element: T): T {\n    const first = this[0];\n    this[0] = element;\n    this.siftDown(0);\n    return first;\n  }\n\n  /**\n   * Returns the right child of an element at a given index.\n   */\n  right(index: number): T {\n    return this[(this.constructor as typeof BinaryHeap).getRightIndex(index)];\n  }\n\n  /**\n   * Extracts the first element of the heap.\n   */\n  shift(): T | undefined {\n    // extract min/max\n    if (this.length < 2) return this.pop();\n    const item = this[0];\n    this[0] = this.pop() as T;\n    this.siftDown(0);\n    return item;\n  }\n\n  siftDown(start: number): void {\n    const { getRightIndex, getLeftIndex, compare } = this\n      .constructor as typeof BinaryHeap;\n    let index = start;\n    let leftIndex = getLeftIndex(index);\n    let rightIndex = getRightIndex(index);\n    let nextIndex;\n    while (this.has(leftIndex)) {\n      if (this.has(rightIndex) && compare(this[rightIndex], this[leftIndex])) {\n        nextIndex = rightIndex;\n      } else {\n        nextIndex = leftIndex;\n      }\n\n      if (compare(this[index], this[nextIndex])) break;\n      [this[index], this[nextIndex]] = [this[nextIndex], this[index]];\n      index = nextIndex;\n      leftIndex = getLeftIndex(index);\n      rightIndex = getRightIndex(index);\n    }\n  }\n\n  siftUp(start: number): void {\n    const { getParentIndex, compare } = this.constructor as typeof BinaryHeap;\n    let index = start;\n    let parentIndex = getParentIndex(index);\n    while (this.has(parentIndex) && !compare(this[parentIndex], this[index])) {\n      [this[index], this[parentIndex]] = [this[parentIndex], this[index]];\n      index = parentIndex;\n      parentIndex = getParentIndex(index);\n    }\n  }\n\n  /**\n   * Changes elements of the heap.\n   *\n   * @param start starting index\n   * @param deleteCount the amount of elements to delete\n   * @param items elements to add\n   * @return the deleted elements\n   */\n  splice(start: number, deleteCount?: number, ...items: Array<T>): Array<T> {\n    const deletedItems = deleteCount === undefined\n      ? super.splice(start)\n      : super.splice(start, deleteCount, ...items);\n    const isSingle = deletedItems.length < 2 && items.length < 2;\n    if (isSingle) {\n      const index = start;\n      const isReplacement = items.length === 1;\n      if (isReplacement) {\n        this.update(index);\n      } else {\n        const last = this.pop();\n        super.splice(index, 0, last as T);\n        this.siftDown(index);\n      }\n    } else {\n      this.heapify();\n    }\n    return deletedItems;\n  }\n\n  /**\n   * Adds elements to the heap.\n   *\n   * @param items elements to add\n   * @return the new length of the heap\n   */\n  unshift(...items: Array<T>): number {\n    return this.push(...items);\n  }\n\n  /**\n   * Updates the position of an element inside the heap.\n   *\n   * @param index the index of the element to update\n   */\n  update(index: number): void {\n    const { compare, getLeftIndex } = this.constructor as typeof BinaryHeap;\n    const parent = this.parent(index);\n    const leftIndex = getLeftIndex(index);\n    if (\n      this.has(leftIndex) &&\n      (parent === undefined || compare(parent, this[index]))\n    ) {\n      this.siftDown(index);\n    } else {\n      this.siftUp(index);\n    }\n  }\n}\n"]}