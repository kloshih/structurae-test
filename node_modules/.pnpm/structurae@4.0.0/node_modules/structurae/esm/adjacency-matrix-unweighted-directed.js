import { getLog2 } from "./utilities.js";
/**
 * Implements the Adjacency Matrix structure for unweighted directed graphs.
 */
export class AdjacencyMatrixUnweightedDirected extends Uint32Array {
    constructor() {
        super(...arguments);
        Object.defineProperty(this, "empty", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_size", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
    }
    static get [Symbol.species]() {
        return Uint32Array;
    }
    get size() {
        return this._size || ((this._size = getLog2(this.vertices)), this._size);
    }
    get vertices() {
        return this[this.length - 1];
    }
    set vertices(value) {
        this[this.length - 1] = value;
        this._size = getLog2(value);
    }
    get edges() {
        return this.vertices ** 2;
    }
    static create(vertices) {
        const length = this.getLength(vertices);
        const matrix = new this(length);
        matrix.vertices = vertices;
        return matrix;
    }
    static getLength(vertices) {
        return ((vertices << getLog2(vertices)) >> 5) + 2;
    }
    addEdge(x, y) {
        const [bucket, position] = this.getCoordinates(x, y);
        if (Number.isNaN(bucket))
            return this;
        this[bucket] = (this[bucket] & ~(1 << position)) | (1 << position);
        return this;
    }
    getCoordinates(x, y = 1) {
        const index = this.getIndex(x, y);
        const bucket = index >> 5;
        if (bucket >= this.length - 1)
            return [NaN, NaN];
        return [bucket, index - (bucket << 5)];
    }
    getEdge(x, y) {
        const [bucket, position] = this.getCoordinates(x, y);
        if (Number.isNaN(bucket))
            return 0;
        return ((this[bucket] >> position) & 1);
    }
    getIndex(x, y) {
        return (x << this.size) + y;
    }
    hasEdge(x, y) {
        return !!this.getEdge(x, y);
    }
    *inEdges(vertex) {
        const { vertices } = this;
        for (let i = 0; i < vertices; i++) {
            if (this.getEdge(i, vertex))
                yield i;
        }
    }
    isFull() {
        return false;
    }
    *outEdges(vertex) {
        const { vertices } = this;
        for (let i = 0; i < vertices; i++) {
            if (this.getEdge(vertex, i))
                yield i;
        }
    }
    removeEdge(x, y) {
        const [bucket, position] = this.getCoordinates(x, y);
        if (Number.isNaN(bucket))
            return this;
        this[bucket] = this[bucket] & ~(1 << position);
        return this;
    }
}
Object.defineProperty(AdjacencyMatrixUnweightedDirected, "directed", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: true
});
Object.defineProperty(AdjacencyMatrixUnweightedDirected, "weighted", {
    enumerable: true,
    configurable: true,
    writable: true,
    value: false
});
//# sourceMappingURL=adjacency-matrix-unweighted-directed.js.map