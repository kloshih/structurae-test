/**
 * Extends Array to implement the Binary Heap data structure.
 * // TODO (docs) document priority queue operations
 * // todo add heapsort?
 */
export class BinaryHeap extends Array {
    // deno-lint-ignore no-explicit-any
    constructor(...args) {
        super(...args);
        this.heapify();
    }
    static get [Symbol.species]() {
        return Array;
    }
    /**
     * The comparator function used by the heap.
     *
     * @param a first value to compare
     * @param b second value to compare
     * @return whether first value is less than the second
     */
    static compare(a, b) {
        return a < b;
    }
    static from(iterable, mapfn, thisArg) {
        return (mapfn !== undefined
            ? super.from(iterable, mapfn, thisArg)
            : super.from(iterable)).heapify();
    }
    /**
     * Get left child index from parent index.
     *
     * @param index the parent index
     * @return the index of the left child
     */
    static getLeftIndex(index) {
        return (index << 1) + 1;
    }
    /**
     * Get left child index from parent index.
     *
     * @param index the child index
     * @return the index of the parent
     */
    static getParentIndex(index) {
        return (index - 1) >> 1;
    }
    /**
     * Get right child index from parent index.
     *
     * @param index the parent index
     * @return the index of the right child
     */
    static getRightIndex(index) {
        return (index << 1) + 2;
    }
    /**
     * Checks if a given collection is a valid binary heap.
     */
    static isHeap(heap) {
        for (let i = heap.length - 1; i > -1; i--) {
            const parentIndex = this.getParentIndex(i);
            if (parentIndex < 0)
                break;
            if (!this.compare(heap[parentIndex], heap[i]))
                return false;
        }
        return true;
    }
    /**
     * Creates a new BinaryHeap with a variable number of arguments,
     * regardless of number or type of the arguments.
     *
     * @param elements the elements of which to create the heap
     * @return the new BinaryHeap
     */
    static of(...elements) {
        return super.of(...elements).heapify();
    }
    /**
     * Check whether the index is whithin the heap.
     */
    has(index) {
        return index >= 0 && index < this.length;
    }
    /**
     * Restores the binary heap.
     */
    heapify() {
        for (let i = this.length >> 1; i >= 0; i--) {
            this.siftDown(i);
        }
        return this;
    }
    /**
     * Checks whether the array is a valid binary heap.
     */
    isHeap() {
        return this.constructor.isHeap(this);
    }
    /**
     * Returns the left child of an element at a given index.
     */
    left(index) {
        return this[this.constructor.getLeftIndex(index)];
    }
    /**
     * Returns the parent of an element at a given index.
     */
    parent(index) {
        return this[this.constructor.getParentIndex(index)];
    }
    /**
     * Adds items to the heap.
     *
     * @param elements items to add
     * @return new length of the heap
     */
    push(...elements) {
        for (let i = 0; i < elements.length; i++) {
            super.push(elements[i]);
            this.siftUp(this.length - 1);
        }
        return this.length;
    }
    /**
     * Returns the first (min/max) element of the heap and replaces it with a given element.
     *
     * @param element the element to replace the first element of the heap
     * @return the first element of the heap
     */
    replace(element) {
        const first = this[0];
        this[0] = element;
        this.siftDown(0);
        return first;
    }
    /**
     * Returns the right child of an element at a given index.
     */
    right(index) {
        return this[this.constructor.getRightIndex(index)];
    }
    /**
     * Extracts the first element of the heap.
     */
    shift() {
        // extract min/max
        if (this.length < 2)
            return this.pop();
        const item = this[0];
        this[0] = this.pop();
        this.siftDown(0);
        return item;
    }
    siftDown(start) {
        const { getRightIndex, getLeftIndex, compare } = this
            .constructor;
        let index = start;
        let leftIndex = getLeftIndex(index);
        let rightIndex = getRightIndex(index);
        let nextIndex;
        while (this.has(leftIndex)) {
            if (this.has(rightIndex) && compare(this[rightIndex], this[leftIndex])) {
                nextIndex = rightIndex;
            }
            else {
                nextIndex = leftIndex;
            }
            if (compare(this[index], this[nextIndex]))
                break;
            [this[index], this[nextIndex]] = [this[nextIndex], this[index]];
            index = nextIndex;
            leftIndex = getLeftIndex(index);
            rightIndex = getRightIndex(index);
        }
    }
    siftUp(start) {
        const { getParentIndex, compare } = this.constructor;
        let index = start;
        let parentIndex = getParentIndex(index);
        while (this.has(parentIndex) && !compare(this[parentIndex], this[index])) {
            [this[index], this[parentIndex]] = [this[parentIndex], this[index]];
            index = parentIndex;
            parentIndex = getParentIndex(index);
        }
    }
    /**
     * Changes elements of the heap.
     *
     * @param start starting index
     * @param deleteCount the amount of elements to delete
     * @param items elements to add
     * @return the deleted elements
     */
    splice(start, deleteCount, ...items) {
        const deletedItems = deleteCount === undefined
            ? super.splice(start)
            : super.splice(start, deleteCount, ...items);
        const isSingle = deletedItems.length < 2 && items.length < 2;
        if (isSingle) {
            const index = start;
            const isReplacement = items.length === 1;
            if (isReplacement) {
                this.update(index);
            }
            else {
                const last = this.pop();
                super.splice(index, 0, last);
                this.siftDown(index);
            }
        }
        else {
            this.heapify();
        }
        return deletedItems;
    }
    /**
     * Adds elements to the heap.
     *
     * @param items elements to add
     * @return the new length of the heap
     */
    unshift(...items) {
        return this.push(...items);
    }
    /**
     * Updates the position of an element inside the heap.
     *
     * @param index the index of the element to update
     */
    update(index) {
        const { compare, getLeftIndex } = this.constructor;
        const parent = this.parent(index);
        const leftIndex = getLeftIndex(index);
        if (this.has(leftIndex) &&
            (parent === undefined || compare(parent, this[index]))) {
            this.siftDown(index);
        }
        else {
            this.siftUp(index);
        }
    }
}
//# sourceMappingURL=binary-heap.js.map